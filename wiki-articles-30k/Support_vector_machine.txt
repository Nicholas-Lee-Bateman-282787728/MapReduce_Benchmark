   In machine learning, support vector machines (SVMs, also support vector networks) are supervised learning models with associated learning algorithms that analyze data used for classification and regression analysis.  Given a set of training examples, each marked for belonging to one of two categories, an SVM training algorithm builds a model that assigns new examples into one category or the other, making it a non-probabilistic binary linear classifier. An SVM model is a representation of the examples as points in space, mapped so that the examples of the separate categories are divided by a clear gap that is as wide as possible. New examples are then mapped into that same space and predicted to belong to a category based on which side of the gap they fall on. In addition to performing linear classification, SVMs can efficiently perform a non-linear classification using what is called the kernel trick, implicitly mapping their inputs into high-dimensional feature spaces. When data is not labeled, a supervised learning is not possible, and an unsupervised learning is required, that would find natural clustering of the data to groups, and map new data to these formed groups. The clustering algorithm which provides an improvement to the support vector machines is called support vector clustering (SVC) and is highly used in industrial applications either when data is not labeled or when only some data is labeled as a preprocessing for a classification pass; the clustering method was published.Ben-Hur, Asa, Horn, David, Siegelmann, Hava, and Vapnik, Vladimir; "Support vector clustering" (2001) Journal of Machine Learning Research, 2: 125–137. More formally, a support vector machine constructs a hyperplane or set of hyperplanes in a high- or infinite-dimensional space, which can be used for classification, regression, or other tasks. Intuitively, a good separation is achieved by the hyperplane that has the largest distance to the nearest training-data point of any class (so-called functional margin), since in general the larger the margin the lower the generalization error of the classifier. Whereas the original problem may be stated in a finite dimensional space, it often happens that the sets to discriminate are not linearly separable in that space. For this reason, it was proposed that the original finite-dimensional space be mapped into a much higher-dimensional space, presumably making the separation easier in that space. To keep the computational load reasonable, the mappings used by SVM schemes are designed to ensure that dot products may be computed easily in terms of the variables in the original space, by defining them in terms of a kernel function k(x,y) selected to suit the problem.*  The hyperplanes in the higher-dimensional space are defined as the set of points whose dot product with a vector in that space is constant. The vectors defining the hyperplanes can be chosen to be linear combinations with parameters \alpha_i of images of feature vectors x_i that occur in the data base. With this choice of a hyperplane, the points x in the feature space that are mapped into the hyperplane are defined by the relation: \textstyle\sum_i \alpha_i k(x_i,x) = \mathrm{constant}.  Note that if k(x,y) becomes small as y grows further away from x, each term in the sum measures the degree of closeness of the test point x to the corresponding data base point x_i. In this way, the sum of kernels above can be used to measure the relative nearness of each test point to the data points originating in one or the other of the sets to be discriminated. Note the fact that the set of points x mapped into any hy a result, allowing much more complex discrimination between sets which are not convex at all in the original space. The original SVM algorithm was invented by Vladimir N. Vapnik and Alexey Ya. Chervonenkis in 1963. In 1992, Bernhard E. Boser, Isabelle M. Guyon and Vladimir N. Vapnik suggested a way to create nonlinear classifiers by applying the kernel trick to maximum-margin hyperplanes. The current standard incarnation (soft margin) was proposed by Corinna Cortes and Vapnik in 1993 and published in 1995.  Classifying data is a common task in machine learning. Suppose some given data points each belong to one of two classes, and the goal is to decide which class a new data point will be in. In the case of support vector machines, a data point is viewed as a p-dimensional vector (a list of p numbers), and we want to know whether we can separate such points with a (p-1)-dimensional hyperplane. This is called a linear classifier. There are many hyperplanes that might classify the data. One reasonable choice as the best hyperplane is the one that represents the largest separation, or margin, between the two classes. So we choose the hyperplane so that the distance from it to the nearest data point on each side is maximized. If such a hyperplane exists, it is known as the maximum-margin hyperplane and the linear classifier it defines is known as a maximum margin classifier; or equivalently, the perceptron of optimal stability. We are given a training dataset of n points of the form  (\vec{x}_1, y_1),\, \ldots ,\, (\vec{x}_n, y_n) where the y_i are either 1 or −1, each indicating the class to which the point \vec{x}_i  belongs. Each  \vec{x}_i  is a p-dimensional real vector. We want to find the "maximum-margin hyperplane" that divides the group of points \vec{x}_i for which y_i=1 from the group of points for which y_i=-1, which is defined so that the distance between the hyperplane and the nearest point \vec{x}_i from either group is maximized. Any hyperplane can be written as the set of points \vec{x} satisfying \vec{w}\cdot\vec{x} - b=0,\,  where {\vec{w}} is the (not necessarily normalized) normal vector to the hyperplane. The parameter \tfrac{b}{\|\vec{w}\|} determines the offset of the hyperplane from the origin along the normal vector {\vec{w}}. If the training data are linearly separable, we can select two parallel hyperplanes that separate the two classes of data, so that the distance between them is as large as possible. The region bounded by these two hyperplanes is called the "margin", and the maximum-margin hyperplane is the hyperplane that lies halfway between them. These hyperplanes can be described by the equations \vec{w}\cdot\vec{x} - b=1\, and \vec{w}\cdot\vec{x} - b=-1.\, Geometrically, the distance between these two hyperplanes is \tfrac{2}{\|\vec{w}\|}, so to maximize the distance between the planes we want to minimize \|\vec{w}\|. As we also have to prevent data points from falling into the margin, we add the following constraint: for each i either \vec{w}\cdot\vec{x}_i - b \ge 1,            if y_i = 1   or \vec{w}\cdot\vec{x}_i - b \le -1,       if y_i = -1.  These constraints state that each data point must lie on the correct side of the margin. This can be rewritten as: y_i(\vec{w}\cdot\vec{x}_i - b) \ge 1, \quad \text{ for all } 1 \le i \le n.\qquad\qquad(1) We can put this together to get the optimization problem:"Minimize \|\vec{w}\| subject to y_i(\vec{w}\cdot\vec{x_i} - b) \ge 1,  for i = 1,\,\ldots,\,n "The \vec w and b that solve this problem determine our classifier,  \vec{x} \mapsto \sgn(\vec{w} \cdot \vec{x} + b). An easy-to-see but important consequence of this geometric description is that max-margin hyperplane is completely determined by those  \vec{x}_i which lie nearest to it. These  \vec{x}_i are called support vectors. To extend SVM to cases in which the data are not linearly separable, we introduce the hinge loss function,\max\left(0, 1-y_i(\vec{w}\cdot\vec{x_i} + b)\right). This function is zero if the constraint in (1) is satisfied, in other words, if \vec{x}_i lies on the correct side of the margin. For data on the wrong side of the margin, the function's value is proportional to the distance from the margin. We then wish to minimize\left[\frac 1 n \sum_{i=1}^n \max\left(0, 1 - y_i(w\cdot x_i + b)\right) \right] + \lambda\lVert w \rVert^2,where the parameter \lambda determines the tradeoff between increasing the margin-size and ensuring that the \vec{x}_i lie on the correct side of the margin. Thus, for sufficiently small values of \lambda, the soft-margin SVM will behave identically to the hard-margin SVM if the input data are linearly classifiable, but will still learn a viable classification rule if not.  The original maximum-margin hyperplane algorithm proposed by Vapnik in 1963 constructed a linear classifier. However, in 1992, Bernhard E. Boser, Isabelle M. Guyon and Vladimir N. Vapnik suggested a way to create nonlinear classifiers by applying the kernel trick (originally proposed by Aizerman et al.) to maximum-margin hyperplanes. The resulting algorithm is formally similar, except that every dot product is replaced by a nonlinear kernel function. This allows the algorithm to fit the maximum-margin hyperplane in a transformed feature space. The transformation may be nonlinear and the transformed space high dimensional; although the classifier is a hyperplane in the transformed feature space, it may be nonlinear in the original input space. It is noteworthy that working in a higher-dimensional feature space increases the generalization error of support vector machines, although given enough samples the algorithm still performs well. Some common kernels include: Computing the (soft-margin) SVM classifier amounts to minimizing an expression of the form\left[\frac 1 n \sum_{i=1}^n \max\left(0, 1 - y_i(w\cdot x_i + b)\right) \right] + \lambda\lVert w \rVert^2. \qquad(2)We focus on the soft-margin classifier since, as noted above, choosing a sufficiently small value for \lambda yields the hard-margin classifier for linearly classifiable input data. The classical approach, which involves reducing (2) to a quadratic programing problem, is detailed below. Then, more recent approaches such as sub-gradient descent and coordinate descent will be discussed. Minimizing (2) can be rewritten as a constrained optimization problem with a differentiable objective function in the following way. For each i \in \{1,\,\ldots,\,n\} we introduce the variable \zeta_i, and note that  \zeta_i = \max\left(0, 1 - y_i(w\cdot x_i + b)\right)  if and only if  \zeta_i is the smallest nonnegative number satisfying  y_i(w\cdot x_i + b) \geq 1- \zeta_i. Thus we can rewrite the optimization problem as follows \text{minimize } \frac 1 n \sum_{i=1}^n \zeta_i + \lambda\|w\|^2  \text{subject to } y_i(x_i \cdot w + b) \geq 1 - \zeta_i \,\text{ and }\,\zeta_i \geq 0,\,\text{for all }i. This is called the primal problem. By solving for the Lagrangian dual of the above problem, one obtains the simplified problem \text{maximize}\,\, f(c_1 \ldots c_n) =  \sum_{i=1}^n c_i - \frac 1 2 \sum_{i=1}^n\sum_{j=1}^n y_ic_i(x_i \cdot x_j)y_jc_j, \text{subject to } \sum_{i=1}^n c_iy_i = 0,\,\text{and } 0 \leq c_i \leq \frac{1}{2n\lambda}\;\text{for all }i.This is called the dual problem. Since the dual minimization problem is a quadratic function of the  c_i subject to linear constraints, it is efficiently solvable by quadratic programming algorithms. Here, the variables  c_i are defined such that \vec w = \sum_{i=1}^n c_iy_i \vec x_i. Moreover,  c_i = 0 exactly when  \vec x_i lies on the correct side of the margin, and  0 < c_i <(2n\lambda)^{-1}</math>  when <math> \vec x_i lies on the margin's boundary. It follows that  \vec w can be written as a linear combination of the support vectors. The offset,  b, can be recovered by finding an  \vec x_i on the margin's boundary and solving  y_i(\vec w \cdot \vec x_i + b) = 1 \iff b = \vec w \cdot \vec x_i - y_i. Suppose now that we would like to learn a nonlinear classification rule which corresponds to a linear classification rule for the transformed data points  \varphi(\vec x_i). Moreover, we are given a kernel function  k which satisfies  k(\vec x_i, \vec x_j) = \varphi(\vec x_i) \cdot \varphi(\vec x_j). We know the classification vector   \vec w in the transformed space satisfies   \vec w = \sum_{i=1}^n c_iy_i\varphi( \vec x_i),where the   c_i are obtained by solving the optimization problem \begin{align} \text{maximize}\,\, f(c_1 \ldots c_n) &=  \sum_{i=1}^n c_i + \frac 1 2 \sum_{i=1}^n\sum_{j=1}^n y_ic_i(\varphi(\vec x_i) \cdot \varphi(\vec x_j))y_jc_j \\                                       &=  \sum_{i=1}^n c_i + \frac 1 2 \sum_{i=1}^n\sum_{j=1}^n y_ic_ik(\vec x_i,\vec x_j)y_jc_j \\ \end{align}  \text{subject to } \sum_{i=1}^n c_iy_i = 0,\,\text{and } 0 \leq c_i \leq \frac{1}{2n\lambda}\;\text{for all }i.The coefficients  c_i can be solved for using quadratic programming, as before. Again, we can find some index  i such that  0 < c_i <(2n\lambda)^{-1}</math>, so that <math> \varphi(\vec x_i) lies on the boundary of the margin in the transformed space, and then solve \begin{align} b = \vec w \cdot \varphi(\vec x_i) - y_i &= \left[\sum_{k=1}^n c_ky_k\varphi(\vec x_k)\cdot\varphi(\vec x_i)\right] - y_i \\   &= \left[\sum_{k=1}^n c_ky_kk(\vec x_k, \vec x_i)\right] - y_i. \end{align}Finally, new points can be classified by computing  \vec z \mapsto \sgn(\vec w \cdot \varphi(\vec z) + b) = \sgn\left(\left[\sum_{i=1}^n c_iy_ik(\vec x_i, \vec z)\right] + b\right). Recent algorithms for finding the SVM classifier include sub-gradient descent and coordinate descent. Both techniques have proven to offer significant advantages over the traditional approach when dealing with large, sparse datasets—sub-gradient methods are especially efficient when there are many training examples, and coordinate descent when the dimension of the feature space is high. Sub-gradient descent algorithms for the SVM work directly with the expressionf(\vec w, b) = \left[\frac 1 n \sum_{i=1}^n \max\left(0, 1 - y_i(w\cdot x_i + b)\right) \right] + \lambda\lVert w \rVert^2.Note that f is a convex function of \vec w and b. As such, traditional gradient descent (or SGD) methods can be adapted, where instead of taking a step in the direction of the functions gradient, a step is taken in the direction of a vector selected from the function's sub-gradient. This approach has the advantage that, for certain implementations, the number of iterations does not scale with n, the number of data points. Coordinate descent algorithms for the SVM work from the dual problem  \text{maximize}\,\, f(c_1 \ldots c_n) =  \sum_{i=1}^n c_i + \frac 1 2 \sum_{i=1}^n\sum_{j=1}^n y_ic_i(x_i \cdot x_j)y_jc_j, \text{subject to } \sum_{i=1}^n c_iy_i = 0,\,\text{and } 0 \leq c_i \leq \frac{1}{2n\lambda}\;\text{for all }i.For each  i \in \{1,\, \ldots,\, n\}, iteratively, the coefficient  c_i is adjusted in the direction of  \partial f/ \partial c_i. Then, the resulting vector of coefficients  (c_1',\,\ldots,\,c_n') is projected onto the nearest vector of coefficients that satisfies the given constraints. (Typically Euclidean distances are used.) The process is then repeated until a near-optimal vector of coefficients is obtained. The resulting algorithm is extremely fast in practice, although few performance guarantees have been proved. The soft-margin Support Vector Machine described above is an example of an empirical risk minimization (ERM) algorithm for the hinge loss. Seen this way, Support Vector Machines belong to a natural class of algorithms for statistical inference, and many of its unique features are due to the behavior of the hinge loss. This perspective can provide further insight into how and why SVMs work, and allow us to better analyze their statistical properties. In supervised learning, one is given a set of training examples X_1 \ldots X_n with labels y_1 \ldots y_n, and wishes to predict y_{n+1} given X_{n+1}. To do so one forms a hypothesis, f, such that f(X_{n+1}) is a "good" approximation of y_{n+1}. A "good" approximation is usually defined with the help of a loss function, \ell(y,z), which characterizes how bad z is as a prediction of y. We would then like to choose a hypothesis that minimizes the expected risk: \varepsilon(f) = \mathbb{E}\left[\ell(y_{n+1}, f(X_{n+1})) \right] In most cases, we don't know the joint distribution of X_{n+1},\,y_{n+1} outright. In these cases, a common strategy is to choose the hypothesis that minimizes the empirical risk: \hat \varepsilon(f) = \frac 1 n \sum_{k=1}^n \ell(y_k, f(X_k)) Under certain assumptions about the sequence of random variables X_k,\, y_k (for example, that they are generated by a finite Markov process), if the set of hypotheses being considered is small enough, the minimizer of the empirical risk will closely approximate the minimizer of the expected risk as n grows large. This approach is called empirical risk minimization, or ERM. In order for the minimization problem to have a well-defined solution, we have to place constraints on the set \mathcal{H} of hypotheses being considered. If \mathcal{H} is a normed space (as is the case for SVM), a particularly effective technique is to consider only those hypotheses  f for which \lVert f \rVert_{\mathcal H} < k</math> . This is equivalent to imposing a ''regularization penalty'' <math>\mathcal R(f) = \lambda_k\lVert f \rVert_{\mathcal H}, and solving the new optimization problem \hat f = \mathrm{arg}\min_{f \in \mathcal{H}} \hat \varepsilon(f) + \mathcal{R}(f). This approach is called Tikhonov regularization. More generally, \mathcal{R}(f) can be some measure of the complexity of the hypothesis f, so that simpler hypotheses are preferred. Recall that the (soft-margin) SVM classifier \hat w, b: x \mapsto \sgn(\hat w \cdot x + b) is chosen to minimize the following expression. \left[\frac 1 n \sum_{i=1}^n \max\left(0, 1 - y_i(w\cdot x_i + b)\right) \right] + \lambda\lVert w \rVert^2 In light of the above discussion, we see that the SVM technique is equivalent to empirical risk minimization with Tikhonov regularization, where in this case the loss function is the hinge loss \ell(y,z) = \max\left(0, 1 - yz \right). From this perspective, SVM is closely related to other fundamental classification algorithms such as regularized least-squares and logistic regression. The difference between the three lies in the choice of loss function: regularized least-squares amounts to empirical risk minimization with the square-loss,  \ell_{sq}(y,z) = (y-z)^2; logistic regression employs the log-loss,  \ell_\log(y,z) = \ln(1 + e^{-yz}). The difference between the hinge loss and these other loss functions is best stated in terms of target functions - the function that minimizes expected risk for a given pair of random variables X,\,y. In particular, let y_x denote y conditional on the event that X = x.  In the classification setting, we have: y_x = \begin{cases} 1 & \text{with probability } p_x \\ -1 & \text{with probability } 1-p_x  \end{cases} The optimal classifier is therefore: f^*(x) = \begin{cases}1 & \text{if }p_x \geq 1/2 \\ -1 & \text{otherwise}\end{cases}  For the square-loss, the target function is the conditional expectation function, f_{sq}(x) = \mathbb{E}\left[y_x\right]; For the logistic loss, it's the logit function, f_\log(x) = \ln\left(p_x / ({1-p_x})\right). While both of these target functions yield the correct classifier, as \sgn(f_{sq}) = \sgn(f_\log) = f^*, they give us more information than we need. In fact, they give us enough information to completely describe the distribution of  y_x. On the other hand, one can check that the target function for the hinge loss is exactly f^*. Thus, in a sufficiently rich hypothesis space—or equivalently, for an appropriately chosen kernel—the SVM classifier will converge to the simplest function (in terms of \mathcal{R}) that correctly classifies the data. This extends the geometric interpretation of SVM—for linear classification, the empirical risk is minimized by any function whose margins lie between the support vectors, and the simplest of these is the max-margin classifier. SVMs belong to a family of generalized linear classifiers and can be interpreted as an extension of the perceptron. They can also be considered a special case of Tikhonov regularization. A special property is that they simultaneously minimize the empirical classification error and maximize the geometric margin; hence they are also known as maximum margin classifiers. A comparison of the SVM to other classifiers has been made by Meyer, Leisch and Hornik. The effectiveness of SVM depends on the selection of kernel, the kernel's parameters, and soft margin parameter C. A common choice is a Gaussian kernel, which has a single parameter \gamma. The best combination of C and \gamma is often selected by a grid search with exponentially growing sequences of C and \gamma, for example, C \in \{ 2^{-5}, 2^{-3}, \dots, 2^{13},2^{15} \}; \gamma \in \{ 2^{-15},2^{-13}, \dots, 2^{1},2^{3} \}. Typically, each combination of parameter choices is checked using cross validation, and the parameters with best cross-validation accuracy are picked. Alternatively, recent work in Bayesian optimization can be used to select C and \gamma , often requiring the evaluation of far fewer parameter combinations than grid search. The final model, which is used for testing and for classifying new data, is then trained on the whole training set using the selected parameters. Potential drawbacks of the SVM are the following three aspects: SVC is a similar method that also builds on kernel functions but is appropriate for unsupervised learning and data-mining. It is considered a fundamental method in Data-Science. Multiclass SVM aims to assign labels to instances by using support vector machines, where the labels are drawn from a finite set of several elements. The dominant approach for doing so is to reduce the single multiclass problem into multiple binary classification problems. Common methods for such reduction include:  Crammer and Singer proposed a multiclass SVM method which casts the multiclass classification problem into a single optimization problem, rather than decomposing it into multiple binary classification problems. See also Lee, Lin and Wahba. Transductive support vector machines extend SVMs in that they could also treat partially labeled data in semi-supervised learning by following the principles of transduction. Here, in addition to the training set \mathcal{D}, the learner is also given a set \mathcal{D}^\star = \{ \vec{x}^\star_i \mid \vec{x}^\star_i \in \mathbb{R}^p\}_{i=1}^k \,  of test examples to be classified. Formally, a transductive support vector machine is defined by the following primal optimization problem:Joachims, Thorsten; "Transductive Inference for Text Classification using Support Vector Machines", Proceedings of the 1999 International Conference on Machine Learning (ICML 1999), pp. 200–209. Minimize (in {\vec{w}, b, \vec{y^\star}}) \frac{1}{2}\|\vec{w}\|^2 subject to (for any i = 1, \dots, n and any j = 1, \dots, k) y_i(\vec{w}\cdot\vec{x_i} - b) \ge 1,\, y^\star_j(\vec{w}\cdot\vec{x^\star_j} - b) \ge 1, and y^\star_j \in \{-1, 1\}.\, Transductive support vector machines were introduced by Vladimir N. Vapnik in 1998. SVMs have been generalized to structured SVMs, where the label space is structured and of possibly infinite size. A version of SVM for regression was proposed in 1996 by Vladimir N. Vapnik, Harris Drucker, Christopher J. C. Burges, Linda Kaufman and Alexander J. Smola.Drucker, Harris; Burges, Christopher J. C.; Kaufman, Linda; Smola, Alexander J.; and Vapnik, Vladimir N. (1997); "Support Vector Regression Machines", in Advances in Neural Information Processing Systems 9, NIPS 1996, 155–161, MIT Press. This method is called support vector regression (SVR). The model produced by support vector classification (as described above) depends only on a subset of the training data, because the cost function for building the model does not care about training points that lie beyond the margin. Analogously, the model produced by SVR depends only on a subset of the training data, because the cost function for building the model ignores any training data close to the model prediction. Another SVM version known as least squares support vector machine (LS-SVM) has been proposed by Suykens and Vandewalle.Suykens, Johan A. K.; Vandewalle, Joos P. L.; Least squares support vector machine classifiers, Neural Processing Letters, vol. 9, no. 3, Jun. 1999, pp. 293–300. Training the original SVR means solving minimize \frac{1}{2} \|w\|^2  subject to \begin{cases}                     y_i - \langle w, x_i \rangle  - b \le \varepsilon  \\                     \langle w, x_i \rangle + b - y_i \le \varepsilon                   \end{cases} where x_i is a training sample with target value y_i. The inner product plus intercept \langle w, x_i \rangle + b is the prediction for that sample, and \varepsilon is a free parameter that serves as a threshold: all predictions have to be within an \varepsilon range of the true predictions. Slack variables are usually added into the above to allow for errors and to allow approximation in the case the above problem is infeasible. The SVM algorithm has been widely applied in the biological and other sciences.  Permutation tests based on SVM weights have been suggested as a mechanism for interpretation of SVM models.Bilwaj Gaonkar, Christos Davatzikos Analytic estimation of statistical significance maps for support vector machine based multi-variate image analysis and classificationR. Cuingnet, C. Rosso, M. Chupin, S. Lehéricy, D. Dormont, H. Benali, Y. Samson and O. Colliot, Spatial regularization of SVM for the detection of diffusion alterations associated with stroke outcome, Medical Image Analysis, 2011, 15 (5): 729–737 Support vector machine weights have also been used to interpret SVM models in the past.Statnikov, A., Hardin, D., & Aliferis, C. (2006). Using SVM weight-based methods to identify causally relevant and non-causally relevant variables. sign, 1, 4. Posthoc interpretation of support vector machine models in order to identify features used by the model to make predictions is a relatively new area of research with special significance in the biological sciences. The parameters of the maximum-margin hyperplane are derived by solving the optimization. There exist several specialized algorithms for quickly solving the QP problem that arises from SVMs, mostly relying on heuristics for breaking the problem down into smaller, more-manageable chunks. Another approach is to use an interior point method that uses Newton-like iterations to find a solution of the Karush–Kuhn–Tucker conditions of the primal and dual problems. Instead of solving a sequence of broken down problems, this approach directly solves the problem altogether. To avoid solving a linear system involving the large kernel matrix, a low rank approximation to the matrix is often used in the kernel trick. Another common method is Platt's Sequential Minimal Optimization (SMO) algorithm, which breaks the problem down into 2-dimensional sub-problems that are solved analytically, eliminating the need for a numerical optimization algorithm and matrix storage. This algorithm is conceptually simple, easy to implement, generally faster, and has better scaling properties for difficult SVM problems. The special case of linear support vector machines can be solved more efficiently by the same kind of algorithms used to optimize its close cousin, logistic regression; this class of algorithms includes sub-gradient descent (e.g., PEGASOS) and coordinate descent (e.g., LIBLINEAR). LIBLINEAR has some attractive training time properties. Each convergence iteration takes time linear in the time taken to read the train data and the iterations also have a Q-Linear Convergence property, making the algorithm extremely fast. The general kernel SVMs can also be solved more efficiently using sub-gradient descent (e.g. P-packSVM), especially when parallelization is allowed. Kernel SVMs are available in many machine learning toolkits, including LIBSVM, MATLAB, SAS, SVMlight, kernlab, scikit-learn, Shogun, Weka, Shark, JKernelMachines, OpenCV and others. SVMs can be used to solve various real world problems: Polynomial (homogeneous): k(\vec{x_i},\vec{x_j})=(\vec{x_i} \cdot \vec{x_j})^d Polynomial (inhomogeneous): k(\vec{x_i},\vec{x_j})=(\vec{x_i} \cdot \vec{x_j} + 1)^d Gaussian radial basis function: k(\vec{x_i},\vec{x_j})=\exp(-\gamma \|\vec{x_i} - \vec{x_j}\|^2), for \gamma > 0. Sometimes parametrized using \gamma=1/{2 \sigma^2} Hyperbolic tangent: k(\vec{x_i},\vec{x_j})=\tanh(\kappa \vec{x_i} \cdot \vec{x_j}+c), for some (not every) \kappa > 0  and  c < 0 </math> The kernel is related to the transform <math>\varphi(\vec{x_i}) by the equation k(\vec{x_i}, \vec{x_j}) = \varphi(\vec{x_i})\cdot \varphi(\vec{x_j}). The value w is also in the transformed space, with \textstyle\vec{w} = \sum_i \alpha_i y_i \varphi(\vec{x}_i). Dot products with w for classification can again be computed by the kernel trick, i.e. \textstyle \vec{w}\cdot\varphi(\vec{x}) = \sum_i \alpha_i y_i k(\vec{x}_i, \vec{x}). Requires full labeling of input data Uncalibrated class membership probabilities The SVM is only directly applicable for two-class tasks. Therefore, algorithms that reduce the multi-class task to several binary problems have to be applied; see the multi-class SVM section. Parameters of a solved model are difficult to interpret. Building binary classifiers which distinguish (i) between one of the labels and the rest (one-versus-all) or (ii) between every pair of classes (one-versus-one). Classification of new instances for the one-versus-all case is done by a winner-takes-all strategy, in which the classifier with the highest output function assigns the class (it is important that the output functions be calibrated to produce comparable scores). For the one-versus-one approach, classification is done by a max-wins voting strategy, in which every classifier assigns the instance to one of the two classes, then the vote for the assigned class is increased by one vote, and finally the class with the most votes determines the instance classification. Directed acyclic graph SVM (DAGSVM) Error-correcting output codes SVMs are helpful in text and hypertext categorization as their application can significantly reduce the need for labeled training instances in both the standard inductive and transductive settings. Classification of images can also be performed using SVMs. Experimental results show that SVMs achieve significantly higher search accuracy than traditional query refinement schemes after just three to four rounds of relevance feedback.  SVMs are also useful in medical science to classify proteins with up to 90% of the compounds classified correctly. Hand-written characters can be recognized using SVM. In situ adaptive tabulation Kernel machines Fisher kernel Platt scaling Polynomial kernel Predictive analytics Regularization perspectives on support vector machines Relevance vector machine, a probabilistic sparse kernel model identical in functional form to SVM Sequential minimal optimization Space mapping Winnow (algorithm) www.support-vector.net  The key book about the method, "An Introduction to Support Vector Machines" with online software Burges, Christopher J. C.; A Tutorial on Support Vector Machines for Pattern Recognition, Data Mining and Knowledge Discovery 2:121–167, 1998 www.kernel-machines.org (general information and collection of research papers) www.support-vector-machines.org (Literature, Review, Software, Links related to Support Vector Machines&nbsp;— Academic Site) videolectures.net (SVM-related video lectures) Karatzoglou, Alexandros et al.; Support Vector Machines in R, Journal of Statistical Software April 2006, Volume 15, Issue 9. libsvm LIBSVM is a popular library of SVM learners liblinear liblinear is a library for large linear classification including some SVMs Shark Shark is a C++ machine learning library implementing various types of SVMs dlib dlib is a C++ library for working with kernel methods and SVMs SVM light is a collection of software tools for learning and classification using SVM. SVMJS live demo is a GUI demo for Javascript implementation of SVMs Gesture Recognition Toolkit contains an easy to use wrapper for libsvm Theodoridis, Sergios; and Koutroumbas, Konstantinos; "Pattern Recognition", 4th Edition, Academic Press, 2009, ISBN 978-1-59749-272-0 Cristianini, Nello; and Shawe-Taylor, John; An Introduction to Support Vector Machines and other kernel-based learning methods, Cambridge University Press, 2000. ISBN 0-521-78019-5 ([ ] SVM Book) Huang, Te-Ming; Kecman, Vojislav; and Kopriva, Ivica (2006); Kernel Based Algorithms for Mining Huge Data Sets, in Supervised, Semi-supervised, and Unsupervised Learning, Springer-Verlag, Berlin, Heidelberg, 260 pp.&nbsp;96 illus., Hardcover, ISBN 3-540-31681-7 [ ] Kecman, Vojislav; Learning and Soft Computing&nbsp;— Support Vector Machines, Neural Networks, Fuzzy Logic Systems, The MIT Press, Cambridge, MA, 2001.[ ] Schölkopf, Bernhard; and Smola, Alexander J.; Learning with Kernels, MIT Press, Cambridge, MA, 2002. ISBN 0-262-19475-9 Schölkopf, Bernhard; Burges, Christopher J. C.; and Smola, Alexander J. (editors); Advances in Kernel Methods: Support Vector Learning, MIT Press, Cambridge, MA, 1999. ISBN 0-262-19416-3. [ ] Shawe-Taylor, John; and Cristianini, Nello; Kernel Methods for Pattern Analysis, Cambridge University Press, 2004. ISBN 0-521-81397-2 ([ ] Kernel Methods Book) Steinwart, Ingo; and Christmann, Andreas; Support Vector Machines, Springer-Verlag, New York, 2008. ISBN 978-0-387-77241-7 ([ ] SVM Book) Tan, Peter Jing; and Dowe, David L. (2004); MML Inference of Oblique Decision Trees, Lecture Notes in Artificial Intelligence (LNAI) 3339, Springer-Verlag, pp. 1082–1088. (This paper uses minimum message length (MML) and actually incorporates probabilistic support vector machines in the leaves of decision trees.) Vapnik, Vladimir N.; The Nature of Statistical Learning Theory, Springer-Verlag, 1995. ISBN 0-387-98780-0 Vapnik, Vladimir N.; and Kotz, Samuel; Estimation of Dependences Based on Empirical Data, Springer, 2006. ISBN 0-387-30865-2, 510 pages [this is a reprint of Vapnik's early book describing philosophy behind SVM approach. The 2006 Appendix describes recent development]. Fradkin, Dmitriy; and Muchnik, Ilya; Support Vector Machines for Classification in Abello, J.; and Carmode, G. (Eds); Discrete Methods in Epidemiology, DIMACS Series in Discrete Mathematics and Theoretical Computer Science, volume 70, pp.&nbsp;13–20, 2006. [ ]. Succinctly describes theoretical ideas behind SVM. Bennett, Kristin P.; and Campbell, Colin; Support Vector Machines: Hype or Hallelujah?, SIGKDD Explorations, 2, 2, 2000, 1–13. [ ]. Excellent introduction to SVMs with helpful figures. Ivanciuc, Ovidiu; Applications of Support Vector Machines in Chemistry, in Reviews in Computational Chemistry, Volume 23, 2007, pp.&nbsp;291–400. Reprint available: [ ] Catanzaro, Bryan; Sundaram, Narayanan; and Keutzer, Kurt; Fast Support Vector Machine Training and Classification on Graphics Processors, in International Conference on Machine Learning, 2008 [ ] Campbell, Colin; and Ying, Yiming; Learning with Support Vector Machines, 2011, Morgan and Claypool. ISBN 978-1-60845-616-1. [ ] Ben-Hur, Asa, Horn, David, Siegelmann, Hava, and Vapnik, Vladimir; "Support vector clustering" (2001) Journal of Machine Learning Research, 2: 125–137.

 In mathematics, matrix multiplication is a binary operation that takes a pair of matrices, and produces another matrix. Numbers such as the real or complex numbers can be multiplied according to elementary arithmetic. On the other hand, matrices are arrays of numbers, so there is no unique way to define "the" multiplication of matrices. As such, in general the term "matrix multiplication" refers to a number of different ways to multiply matrices. The key features of any matrix multiplication include: the number of rows and columns the original matrices have (called the "size", "order" or "dimension"), and specifying how the entries of the matrices generate the new matrix. Like vectors, matrices of any size can be multiplied by scalars, which amounts to multiplying every entry of the matrix by the same number. Similar to the entrywise definition of adding or subtracting matrices, multiplication of two matrices of the same size can be defined by multiplying the corresponding entries, and this is known as the Hadamard product. Another definition is the Kronecker product of two matrices, to obtain a block matrix. One can form many other definitions. However, the most useful definition can be motivated by linear equations and linear transformations on vectors, which have numerous applications in applied mathematics, physics, and engineering. This definition is often called the matrix product. In words, if  is an  matrix and  is an  matrix, their matrix product  is an  matrix, in which the  entries across the rows of  are multiplied with the  entries down the columns of  (the precise definition is below). This definition is not commutative, although it still retains the associative property and is distributive over entrywise addition of matrices. The identity element of the matrix product is the identity matrix (analogous to multiplying numbers by 1), and a square matrix may have an inverse matrix (analogous to the multiplicative inverse of a number). Determinant multiplicativity applies to the matrix product. The matrix product is an important operation in linear transformations, matrix groups, and the theory of group representations and irreps. Computing matrix products is both a central operation in many numerical algorithms and potentially time consuming, making it one of the most well-studied problems in numerical computing. Various algorithms have been devised for computing , especially for large matrices. This article will use the following notational conventions: matrices are represented by capital letters in bold, e.g. , vectors in lowercase bold, e.g. , and entries of vectors and matrices are italic (since they are numbers from a field), e.g.  and . Index notation is often the clearest way to express definitions, and is used as standard in the literature. The  entry of matrix  is indicated by  or , whereas a numerical label (not matrix entries) on a collection of matrices is subscripted only, e.g. , etc. The simplest form of multiplication associated with matrices is scalar multiplication, which is a special case of the Kronecker product. The left scalar multiplication of a matrix  with a scalar  gives another matrix  of the same size as . The entries of  are defined by  (\lambda \mathbf{A})_{ij} = \lambda\left(\mathbf{A}\right)_{ij}\,, explicitly:  \lambda \mathbf{A} = \lambda \begin{pmatrix} A_{11} & A_{12} & \cdots & A_{1m} \\ A_{21} & A_{22} & \cdots & A_{2m} \\ \vdots & \vdots & \ddots & \vdots \\ A_{n1} & A_{n2} & \cdots & A_{nm} \\ \end{pmatrix} = \begin{pmatrix} \lambda A_{11} & \lambda A_{12} & \cdots & \lambda A_{1m} \\ \lambda A_{21} & \lambda A_{22} & \cdots & \lambda A_{2m} \\ \vdots & \vdots & \ddots & \vdots \\ \lambda A_{n1} & \lambda A_{n2} & \cdots & \lambda A_{nm} \\ \end{pmatrix}\,. Similarly, the right scalar multiplication of a matrix  with a scalar  is defined to be  (\mathbf{A}\lambda)_{ij} = \left(\mathbf{A}\right)_{ij} \lambda\,,  explicitly:  \mathbf{A}\lambda = \begin{pmatrix} A_{11} & A_{12} & \cdots & A_{1m} \\ A_{21} & A_{22} & \cdots & A_{2m} \\ \vdots & \vdots & \ddots & \vdots \\ A_{n1} & A_{n2} & \cdots & A_{nm} \\ \end{pmatrix}\lambda = \begin{pmatrix} A_{11} \lambda & A_{12} \lambda & \cdots & A_{1m} \lambda \\  A_{21} \lambda & A_{22} \lambda & \cdots & A_{2m} \lambda \\ \vdots & \vdots & \ddots & \vdots \\ A_{n1} \lambda & A_{n2} \lambda & \cdots & A_{nm} \lambda \\ \end{pmatrix}\,. When the underlying ring is commutative, for example, the real or complex number field, these two multiplications are the same, and are simply called scalar multiplication. However, for matrices over a more general ring that are not commutative, such as the quaternions, they may not be equal. For a real scalar and matrix:  \lambda = 2, \quad \mathbf{A} =\begin{pmatrix} a & b \\ c & d \\ \end{pmatrix}   2 \mathbf{A} = 2 \begin{pmatrix} a & b \\ c & d \\ \end{pmatrix} = \begin{pmatrix} 2 \!\cdot\! a & 2 \!\cdot\! b \\ 2 \!\cdot\! c & 2 \!\cdot\! d \\ \end{pmatrix} = \begin{pmatrix} a \!\cdot\! 2 & b \!\cdot\! 2 \\ c \!\cdot\! 2 & d \!\cdot\! 2 \\ \end{pmatrix} = \begin{pmatrix} a & b \\ c & d \\ \end{pmatrix}2= \mathbf{A}2. For quaternion scalars and matrices:  \lambda = i, \quad \mathbf{A} = \begin{pmatrix}     i & 0 \\     0 & j \\   \end{pmatrix}     i\begin{pmatrix}     i & 0 \\     0 & j \\   \end{pmatrix} = \begin{pmatrix}     i^2 & 0 \\     0 & ij \\   \end{pmatrix} = \begin{pmatrix}     -1 & 0 \\      0 & k \\   \end{pmatrix} \ne \begin{pmatrix}     -1 & 0 \\     0 & -k \\   \end{pmatrix} = \begin{pmatrix}     i^2 & 0 \\     0 & ji \\   \end{pmatrix} = \begin{pmatrix}     i & 0 \\     0 & j \\   \end{pmatrix}i\,,  where  are the quaternion units. The non-commutativity of quaternion multiplication prevents the transition of changing  to . Assume two matrices are to be multiplied (the generalization to any number is discussed below). If  is an  matrix and  is an  matrix, \mathbf{A}=\begin{pmatrix}  A_{11} & A_{12} & \cdots & A_{1m} \\  A_{21} & A_{22} & \cdots & A_{2m} \\ \vdots & \vdots & \ddots & \vdots \\  A_{n1} & A_{n2} & \cdots & A_{nm} \\ \end{pmatrix},\quad\mathbf{B}=\begin{pmatrix}  B_{11} & B_{12} & \cdots & B_{1p} \\  B_{21} & B_{22} & \cdots & B_{2p} \\ \vdots & \vdots & \ddots & \vdots \\  B_{m1} & B_{m2} & \cdots & B_{mp} \\ \end{pmatrix} the matrix product  (denoted without multiplication signs or dots) is defined to be the  matrix \mathbf{A}\mathbf{B} =\begin{pmatrix}  \left(\mathbf{AB}\right)_{11} & \left(\mathbf{AB}\right)_{12} & \cdots & \left(\mathbf{AB}\right)_{1p} \\  \left(\mathbf{AB}\right)_{21} & \left(\mathbf{AB}\right)_{22} & \cdots & \left(\mathbf{AB}\right)_{2p} \\ \vdots & \vdots & \ddots & \vdots \\  \left(\mathbf{AB}\right)_{n1} & \left(\mathbf{AB}\right)_{n2} & \cdots & \left(\mathbf{AB}\right)_{np} \\ \end{pmatrix} where each  entry is given by multiplying the entries  (across row  of ) by the entries  (down column  of ), for , and summing the results over :  (\mathbf{A}\mathbf{B})_{ij} = \sum_{k=1}^m A_{ik}B_{kj}\,.  Thus the product  is defined only if the number of columns in  is equal to the number of rows in , in this case . Each entry may be computed one at a time. Sometimes, the summation convention is used as it is understood to sum over the repeated index . To prevent any ambiguity, this convention will not be used in the article. Usually the entries are numbers or expressions, but can even be matrices themselves (see block matrix). The matrix product can still be calculated exactly the same way. See below for details on how the matrix product can be calculated in terms of blocks taking the forms of rows and columns. The figure to the right illustrates diagrammatically the product of two matrices  and , showing how each intersection in the product matrix corresponds to a row of  and a column of .  \overset{4\times 2 \text{ matrix}}{\begin{bmatrix} {\color{Brown}{a_{11}}} & {\color{Brown}{a_{12}}} \\ \cdot & \cdot \\ {\color{Orange}{a_{31}}} & {\color{Orange}{a_{32}}} \\ \cdot & \cdot \\ \end{bmatrix}}  \overset{2\times 3\text{ matrix}}{\begin{bmatrix} \cdot & {\color{Plum}{b_{12}}} & {\color{Violet}{b_{13}}} \\ \cdot & {\color{Plum}{b_{22}}} & {\color{Violet}{b_{23}}} \\ \end{bmatrix}}  = \overset{4\times 3\text{ matrix}}{\begin{bmatrix} \cdot & x_{12} & x_{13} \\ \cdot & \cdot & \cdot \\ \cdot & x_{32} & x_{33} \\ \cdot & \cdot & \cdot \\ \end{bmatrix}}  The values at the intersections marked with circles are: \begin{align} x_{12} & = {\color{Brown}{a_{11}}}{\color{Plum}{b_{12}}} + {\color{Brown}{a_{12}}}{\color{Plum}{b_{22}}} \\ x_{13} & = {\color{Brown}{a_{11}}}{\color{Violet}{b_{13}}} + {\color{Brown}{a_{12}}}{\color{Violet}{b_{23}}} \\ x_{32} & = {\color{Orange}{a_{31}}}{\color{Plum}{b_{12}}} + {\color{Orange}{a_{32}}}{\color{Plum}{b_{22}}} \\ x_{33} & = {\color{Orange}{a_{31}}}{\color{Violet}{b_{13}}} + {\color{Orange}{a_{32}}}{\color{Violet}{b_{23}}} \end{align} If \mathbf{A} = \begin{pmatrix} a & b & c \end{pmatrix}\,, \quad \mathbf{B} = \begin{pmatrix} x \\ y \\ z \end{pmatrix}\,, their matrix products are: \mathbf{AB} = \begin{pmatrix} a & b & c \end{pmatrix} \begin{pmatrix} x \\ y \\ z \end{pmatrix} = ax + by + cz \,,  and \mathbf{BA} = \begin{pmatrix} x \\ y \\ z \end{pmatrix}\begin{pmatrix} a & b & c \end{pmatrix} = \begin{pmatrix} xa & xb & xc \\ ya & yb & yc \\ za & zb & zc \end{pmatrix} \,.  Note  and  are two different matrices: the first is a  matrix while the second is a  matrix. Such expressions occur for real-valued Euclidean vectors in Cartesian coordinates, displayed as row and column matrices, in which case  is the matrix form of their dot product, while  the matrix form of their dyadic or tensor product. If \mathbf{A} = \begin{pmatrix} a & b & c \\ p & q & r \\ u & v & w \end{pmatrix}, \quad \mathbf{B} = \begin{pmatrix} x \\ y \\ z \end{pmatrix}\,, their matrix product is: \mathbf{AB} = \begin{pmatrix} a & b & c \\ p & q & r \\ u & v & w \end{pmatrix} \begin{pmatrix} x \\ y \\ z \end{pmatrix} =\begin{pmatrix} ax + by + cz \\ px + qy + rz \\ ux + vy + wz \end{pmatrix}\,,  however  is not defined. The product of a square matrix multiplied by a column matrix arises naturally in linear algebra; for solving linear equations and representing linear transformations. By choosing  in  appropriately,  can represent a variety of transformations such as rotations, scaling and reflections, shears, of a geometric shape in space. If \mathbf{A} = \begin{pmatrix} a & b & c \\ p & q & r \\ u & v & w \end{pmatrix}, \quad \mathbf{B} = \begin{pmatrix} \alpha & \beta & \gamma \\ \lambda & \mu & \nu \\ \rho & \sigma & \tau \\ \end{pmatrix}\,, their matrix products are: \mathbf{AB} = \begin{pmatrix} a & b & c \\ p & q & r \\ u & v & w \end{pmatrix} \begin{pmatrix} \alpha & \beta & \gamma \\ \lambda & \mu & \nu \\ \rho & \sigma & \tau \\ \end{pmatrix} =\begin{pmatrix} a\alpha + b\lambda + c\rho & a\beta + b\mu + c\sigma & a\gamma + b\nu + c\tau \\ p\alpha + q\lambda + r\rho & p\beta + q\mu + r\sigma & p\gamma + q\nu + r\tau \\ u\alpha + v\lambda + w\rho & u\beta + v\mu + w\sigma & u\gamma + v\nu + w\tau \end{pmatrix}\,,  and \mathbf{BA} = \begin{pmatrix} \alpha & \beta & \gamma \\ \lambda & \mu & \nu \\ \rho & \sigma & \tau \\ \end{pmatrix} \begin{pmatrix} a & b & c \\ p & q & r \\ u & v & w \end{pmatrix} =\begin{pmatrix} \alpha a + \beta p + \gamma u & \alpha b + \beta q + \gamma v & \alpha c + \beta r + \gamma w \\ \lambda a + \mu p + \nu u & \lambda b + \mu q + \nu v & \lambda c + \mu r + \nu w \\ \rho a + \sigma p + \tau u & \rho b + \sigma q + \tau v & \rho c + \sigma r + \tau w \end{pmatrix}\,.  In this case, both products  and  are defined, and the entries show that  and  are not equal in general. Multiplying square matrices which represent linear transformations corresponds to the composite transformation (see below for details). If \mathbf{A} = \begin{pmatrix} a & b & c \end{pmatrix}\,, \quad \mathbf{B} = \begin{pmatrix} \alpha & \beta & \gamma \\ \lambda & \mu & \nu \\ \rho & \sigma & \tau \\ \end{pmatrix}\,, \quad \mathbf{C} = \begin{pmatrix} x \\ y \\ z \end{pmatrix}\,, their matrix product is: \begin{align} \mathbf{ABC} & = \begin{pmatrix} a & b & c \end{pmatrix} \left[\begin{pmatrix} \alpha & \beta & \gamma \\ \lambda & \mu & \nu \\ \rho & \sigma & \tau \\ \end{pmatrix} \begin{pmatrix} x \\ y \\ z \end{pmatrix} \right] = \left[ \begin{pmatrix} a & b & c \end{pmatrix} \begin{pmatrix} \alpha & \beta & \gamma \\ \lambda & \mu & \nu \\ \rho & \sigma & \tau \\ \end{pmatrix} \right] \begin{pmatrix} x \\ y \\ z \end{pmatrix} \\ & = \begin{pmatrix} a & b & c \end{pmatrix}\begin{pmatrix} \alpha x + \beta y + \gamma z \\ \lambda x + \mu y + \nu z \\ \rho x + \sigma y + \tau z \\ \end{pmatrix} = \begin{pmatrix} a\alpha + b\lambda + c\rho & a\beta + b\mu + c\sigma & a\gamma + b\nu + c\tau \end{pmatrix} \begin{pmatrix} x \\ y \\ z \end{pmatrix}\\ & = a\alpha x + b\lambda x + c\rho x + a\beta y + b\mu y + c\sigma y + a\gamma z + b\nu z + c\tau z \,,\end{align}  however  is not defined. Note that , this is one of many general properties listed below. Expressions of the form  occur when calculating the inner product of two vectors displayed as row and column vectors in an arbitrary coordinate system, and the metric tensor in these coordinates written as the square matrix. If \mathbf{A} = \begin{pmatrix} a & b & c \\ x & y & z \end{pmatrix}\,, \quad \mathbf{B} = \begin{pmatrix} \alpha & \rho \\ \beta & \sigma \\ \gamma & \tau \\ \end{pmatrix}\,, their matrix products are: \mathbf{A}\mathbf{B} = \begin{pmatrix} a & b & c \\ x & y & z \end{pmatrix} \begin{pmatrix} \alpha & \rho \\ \beta & \sigma \\ \gamma & \tau \\ \end{pmatrix} = \begin{pmatrix} a\alpha + b\beta + c \gamma & a\rho + b\sigma + c \tau \\ x\alpha + y\beta + z \gamma & x\rho + y\sigma + z \tau \\ \end{pmatrix} \,, and \mathbf{B}\mathbf{A} = \begin{pmatrix} \alpha & \rho \\ \beta & \sigma \\ \gamma & \tau \\ \end{pmatrix}\begin{pmatrix} a & b & c \\ x & y & z \end{pmatrix} = \begin{pmatrix} \alpha a + \rho x & \alpha b + \rho y & \alpha c + \rho z \\ \beta a + \sigma x & \beta b + \sigma y & \beta c + \sigma z \\ \gamma a + \tau x & \gamma b + \tau y & \gamma c + \tau z \end{pmatrix} \,. Analogous to numbers (elements of a field), matrices satisfy the following general properties, although there is one subtlety, due to the nature of matrix multiplication. Matrix multiplication can be extended to the case of more than two matrices, provided that for each sequential pair, their dimensions match. The product of  matrices  with sizes  (where  are all simply positive integers and the subscripts are labels corresponding to the matrices, nothing more), is the  matrix:  \prod_{i=1}^n \mathbf{A}_i = \mathbf{A}_1\mathbf{A}_2\cdots\mathbf{A}_n \, .  In index notation:  \left(\mathbf{A}_1\mathbf{A}_2\cdots\mathbf{A}_n\right)_{i_0 i_n} = \sum_{i_1=1}^{s_1}\sum_{i_2=1}^{s_2}\cdots\sum_{i_{n-1}=1}^{s_{n-1}} \left(\mathbf{A}_1\right)_{i_0 i_1}\left(\mathbf{A}_2\right)_{i_1 i_2}\left(\mathbf{A}_3\right)_{i_2 i_3} \cdots \left(\mathbf{A}_{n-1}\right)_{i_{n-2}i_{n-1}}\left(\mathbf{A}_n\right)_{i_{n-1}i_n}  The same properties will hold, as long as the ordering of matrices is not changed. Some of the previous properties for more than two matrices generalize as follows. Similarity transformations involving similar matrices are matrix products of the three square matrices, in the form: \mathbf{B} = \mathbf{P}^{-1} \mathbf{A} \mathbf{P} where  is the similarity matrix and  and  are said to be similar if this relation holds. This product appears frequently in linear algebra and applications, such as diagonalizing square matrices and the equivalence between different matrix representations of the same linear operator. More operations on square matrices can be defined using the matrix product, such as powers and nth roots by repeated matrix products, the matrix exponential can be defined by a power series, the matrix logarithm is the inverse of matrix exponentiation, and so on. Square matrices can be multiplied by themselves repeatedly in the same way as ordinary numbers, because they always have the same number of rows and columns. This repeated multiplication can be described as a power of the matrix, a special case of the ordinary matrix product. On the contrary, rectangular matrices do not have the same number of rows and columns so they can never be raised to a power. An  matrix  raised to a positive integer  is defined as \mathbf{A}^k = \underset{k \mathrm{\, times}}{\mathbf{A}\mathbf{A}\cdots\mathbf{A}} and the following identities hold, where  is a scalar: The naive computation of matrix powers is to multiply  times the matrix  to the result, starting with the identity matrix just like the scalar case. This can be improved using exponentiation by squaring, a method commonly used for scalars. For diagonalizable matrices, an even better method is to use the eigenvalue decomposition of . Another method based on the Cayley–Hamilton theorem finds an identity using the matrices' characteristic polynomial, producing a more effective equation for  in which a scalar is raised to the required power, rather than an entire matrix. A special case is the power of a diagonal matrix. Since the product of diagonal matrices amounts to simply multiplying corresponding diagonal elements together, the power  of a diagonal matrix  will have entries raised to the power. Explicitly;    \mathbf{A}^k = \begin{pmatrix}     A_{11} & 0 & \cdots & 0 \\     0 & A_{22} & \cdots & 0 \\     \vdots & \vdots & \ddots & \vdots \\     0 & 0 & \cdots & A_{nn}   \end{pmatrix}^k = \begin{pmatrix}     A_{11}^k & 0 & \cdots & 0 \\     0 & A_{22}^k &  \cdots & 0 \\     \vdots & \vdots & \ddots & \vdots \\     0 & 0 & \cdots & A_{nn}^k   \end{pmatrix}  meaning it is easy to raise a diagonal matrix to a power. When raising an arbitrary matrix (not necessarily a diagonal matrix) to a power, it is often helpful to exploit this property by diagonalizing the matrix first. Matrices offer a concise way of representing linear transformations between vector spaces, and matrix multiplication corresponds to the composition of linear transformations. The matrix product of two matrices can be defined when their entries belong to the same ring, and hence can be added and multiplied. Let , and  be vector spaces over the same field with given bases,  and  be linear transformations and  be their composition. Suppose that , and  are the matrices representing the transformations , and  with respect to the given bases. Then , that is, the matrix of the composition (or the product) of linear transformations is the product of their matrices with respect to the given bases. A system of linear equations with the same number of equations as variables can be solved by collecting the coefficients of the equations into a square matrix, then inverting the matrix equation. A similar procedure can be used to solve a system of linear differential equations, see also phase plane. Given two column vectors  and , the Euclidean inner product and outer product are the simplest special cases of the matrix product.Mathematical methods for physics and engineering, K.F. Riley, M.P. Hobson, S.J. Bence, Cambridge University Press, 2010, ISBN 978-0-521-86153-3 The inner product of two vectors in matrix form is equivalent to a column vector multiplied on its left by a row vector: \begin{align} \mathbf{a}\cdot\mathbf{b} &=\mathbf{a}^\mathrm{T}\mathbf{b}\\ &=\begin{pmatrix}a_1 & a_2 & \cdots & a_n\end{pmatrix}\begin{pmatrix}b_1 \\ b_2 \\ \vdots \\ b_n\end{pmatrix}\\ &=a_1b_1+a_2b_2+\cdots+a_nb_n\\ &=\sum_{i=1}^n a_ib_i, \end{align} where  denotes the transpose of a. The matrix product itself can be expressed in terms of inner product. Suppose that the first  matrix A is decomposed into its row vectors , and the second  matrix  into its column vectors : \mathbf{A} = \begin{pmatrix} A_{1 1} & A_{1 2} & \cdots & A_{1 m} \\ A_{2 1} & A_{2 2} & \cdots & A_{2 m} \\ \vdots & \vdots & \ddots & \vdots \\ A_{n 1} & A_{n 2} & \cdots & A_{n m} \end{pmatrix} =  \begin{pmatrix} \mathbf{a}_1 \\ \mathbf{a}_2 \\ \vdots \\ \mathbf{a}_n \end{pmatrix}, \mathbf{B} = \begin{pmatrix} B_{1 1} & B_{1 2} & \cdots & B_{1 p} \\ B_{2 1} & B_{2 2} & \cdots & B_{2 p} \\ \vdots & \vdots & \ddots & \vdots \\ B_{m 1} & B_{m 2} & \cdots & B_{m p} \end{pmatrix} = \begin{pmatrix} \mathbf{b}_1 & \mathbf{b}_2 & \cdots & \mathbf{b}_p \end{pmatrix}  where \mathbf{a}_i = \begin{pmatrix}A_{i1} & A_{i2} & \cdots & A_{im} \end{pmatrix}\,,\quad \mathbf{b}_i = \begin{pmatrix}B_{1i} \\ B_{2i} \\ \vdots \\ B_{mi}\end{pmatrix}  Then:  \mathbf{AB} = \begin{pmatrix} \mathbf{a}_1 \\ \mathbf{a}_2 \\ \vdots \\ \mathbf{a}_n \end{pmatrix} \begin{pmatrix} \mathbf{b}_1 & \mathbf{b}_2 & \dots & \mathbf{b}_p \end{pmatrix} = \begin{pmatrix} (\mathbf{a}_1 \cdot \mathbf{b}_1) & (\mathbf{a}_1 \cdot \mathbf{b}_2) & \dots & (\mathbf{a}_1 \cdot \mathbf{b}_p) \\ (\mathbf{a}_2 \cdot \mathbf{b}_1) & (\mathbf{a}_2 \cdot \mathbf{b}_2) & \dots & (\mathbf{a}_2 \cdot \mathbf{b}_p) \\ \vdots & \vdots & \ddots & \vdots \\ (\mathbf{a}_n \cdot \mathbf{b}_1) & (\mathbf{a}_n \cdot \mathbf{b}_2) & \dots & (\mathbf{a}_n \cdot \mathbf{b}_p) \end{pmatrix}  It is also possible to express a matrix product in terms of concatenations of products of matrices and row or column vectors:  \mathbf{AB} = \begin{pmatrix} \mathbf{A}\mathbf{b}_1 & \mathbf{A}\mathbf{b}_2 & \dots & \mathbf{A}\mathbf{b}_p \end{pmatrix} = \begin{pmatrix} \mathbf{a}_1\mathbf{B} \\ \mathbf{a}_2\mathbf{B}\\ \vdots\\ \mathbf{a}_n\mathbf{B} \end{pmatrix}  These decompositions are particularly useful for matrices that are envisioned as concatenations of particular types of row vectors or column vectors, e.g. orthogonal matrices (whose rows and columns are unit vectors orthogonal to each other) and Markov matrices (whose rows or columns sum to 1). The outer product (also known as the dyadic product or tensor product) of two vectors in matrix form is equivalent to a row vector multiplied on the left by a column vector: \begin{align} \mathbf{a}\otimes\mathbf{b} &=\mathbf{a}\mathbf{b}^\mathrm{T}\\ &=\begin{pmatrix}a_1 \\ a_2 \\ \vdots \\ a_n\end{pmatrix} \begin{pmatrix}b_1 & b_2 & \cdots & b_n\end{pmatrix}\\ &=\begin{pmatrix} a_1 b_1 & a_1 b_2 & \cdots & a_1 b_n \\ a_2 b_1 & a_2 b_2 & \cdots & a_2 b_n \\ \vdots & \vdots & \ddots & \vdots \\ a_n b_1 & a_n b_2 & \cdots & a_n b_n \\ \end{pmatrix}. \end{align} An alternative method is to express the matrix product in terms of the outer product. The decomposition is done the other way around, the first matrix  is decomposed into column vectors  and the second matrix  into row vectors : \begin{align} \mathbf{AB} &=\begin{pmatrix} \mathbf{\bar a}_1 & \mathbf{\bar a}_2 & \cdots & \mathbf{\bar a}_m \end{pmatrix}\begin{pmatrix} \mathbf{\bar b}_1 \\ \mathbf{\bar b}_2 \\ \vdots \\ \mathbf{\bar b}_m \end{pmatrix}\\ &=\mathbf{\bar a}_1 \otimes \mathbf{\bar b}_1 + \mathbf{\bar a}_2 \otimes \mathbf{\bar b}_2 + \cdots + \mathbf{\bar a}_m \otimes \mathbf{\bar b}_m\\ &=\sum_{i=1}^m \mathbf{\bar a}_i \otimes \mathbf{\bar b}_i \end{align} where this time \mathbf{\bar a}_i = \begin{pmatrix}A_{1i} \\ A_{2i} \\ \vdots \\ A_{ni} \end{pmatrix}\,,\quad \mathbf{\bar b}_i = \begin{pmatrix}B_{i1} & B_{i2} & \cdots & B_{ip}\end{pmatrix}\,. This method emphasizes the effect of individual column/row pairs on the result, which is a useful point of view with e.g. covariance matrices, where each such pair corresponds to the effect of a single sample point. \begin{align} \begin{pmatrix} {\color{Brown}1} & {\color{Orange}2} &  {\color{Violet}3} \\ {\color{Brown}4} & {\color{Orange}5} &  {\color{Violet}6} \\ {\color{Brown}7} & {\color{Orange}8} &  {\color{Violet}9} \\ \end{pmatrix} \begin{pmatrix} {\color{Brown}a} & {\color{Brown}d} \\ {\color{Orange}b} & {\color{Orange}e} \\ {\color{Violet}c} & {\color{Violet}f} \\ \end{pmatrix} &= \begin{pmatrix} {\color{Brown}1} \\ {\color{Brown}4} \\ {\color{Brown}7}  \\ \end{pmatrix} \begin{pmatrix} {\color{Brown}{a}} & {\color{Brown}{d}} \\ \end{pmatrix} + \begin{pmatrix} {\color{Orange}2} \\ {\color{Orange}5} \\ {\color{Orange}8}\\ \end{pmatrix} \begin{pmatrix} {\color{Orange}{b}} & {\color{Orange}{e}} \\ \end{pmatrix}+ \begin{pmatrix} {\color{Violet}3} \\ {\color{Violet}6} \\ {\color{Violet}9}  \\ \end{pmatrix} \begin{pmatrix} {\color{Violet}c}  & {\color{Violet}f}  \\ \end{pmatrix} \\&= \begin{pmatrix} {\color{Brown}{1a}} & {\color{Brown}{1d}} \\ {\color{Brown}{4a}} & {\color{Brown}{4d}} \\ {\color{Brown}{7a}} & {\color{Brown}{7d}} \\ \end{pmatrix}+ \begin{pmatrix} {\color{Orange}{2b}} & {\color{Orange}{2e}} \\ {\color{Orange}{5b}} & {\color{Orange}{5e}} \\ {\color{Orange}{8b}} & {\color{Orange}{8e}} \\ \end{pmatrix}+ \begin{pmatrix} {\color{Violet}{3c}} & {\color{Violet}{3f}} \\ {\color{Violet}{6c}} & {\color{Violet}{6f}} \\ {\color{Violet}{9c}} & {\color{Violet}{9f}} \\ \end{pmatrix} \\&= \begin{pmatrix} {\color{Brown}{1a}} + {\color{Orange}{2b}} + {\color{Violet}{3c}} & {\color{Brown}{1d}} + {\color{Orange}{2e}} + {\color{Violet}{3f}} \\ {\color{Brown}{4a}} + {\color{Orange}{5b}} + {\color{Violet}{6c}} & {\color{Brown}{4d}} + {\color{Orange}{5e}} + {\color{Violet}{6f}} \\ {\color{Brown}{7a}} + {\color{Orange}{8b}} + {\color{Violet}{9c}} & {\color{Brown}{7d}} + {\color{Orange}{8e}} + {\color{Violet}{9f}} \\ \end{pmatrix}. \end{align}   The running time of square matrix multiplication, if carried out naïvely, is . The running time for multiplying rectangular matrices (one -matrix with one -matrix) is , however, more efficient algorithms exist, such as Strassen's algorithm, devised by Volker Strassen in 1969 and often referred to as "fast matrix multiplication". It is based on a way of multiplying two -matrices which requires only 7 multiplications (instead of the usual 8), at the expense of several additional addition and subtraction operations. Applying this recursively gives an algorithm with a multiplicative cost of O( n^{\log_{2}7}) \approx O(n^{2.807}). Strassen's algorithm is more complex, and the numerical stability is reduced compared to the naïve algorithm. Nevertheless, it appears in several libraries, such as BLAS, where it is significantly more efficient for matrices with dimensions n > 100,Press 2007, p.&nbsp;108. and is very useful for large matrices over exact domains such as finite fields, where numerical stability is not an issue. The current  algorithm with the lowest known exponent  is a generalization of the Coppersmith–Winograd algorithm that has an asymptotic complexity of , by François Le Gall.. The original algorithm was presented by Don Coppersmith and Shmuel Winograd in 1990, has an asymptotic complexity of . It was improved in 2013 to  by Virginia Vassilevska Williams, giving a time only slightly worse than Le Gall's improvement:   This algorithm, and the Coppersmith–Winograd algorithm on which it is based, are similar to Strassen's algorithm: a way is devised for multiplying two -matrices with fewer than  multiplications, and this technique is applied recursively. However, the constant coefficient hidden by the Big O notation is so large that these algorithms are only worthwhile for matrices that are too large to handle on present-day computers. Since any algorithm for multiplying two -matrices has to process all -entries, there is an asymptotic lower bound of  operations. Raz (2002) proves a lower bound of  for bounded coefficient arithmetic circuits over the real or complex numbers. Cohn et al. (2003, 2005) put methods such as the Strassen and Coppersmith–Winograd algorithms in an entirely different group-theoretic context, by utilising triples of subsets of finite groups which satisfy a disjointness property called the triple product property (TPP). They show that if families of wreath products of Abelian groups with symmetric groups realise families of subset triples with a simultaneous version of the TPP, then there are matrix multiplication algorithms with essentially quadratic complexity. Most researchers believe that this is indeed the case.Robinson, 2005. However, Alon, Shpilka and Chris Umans have recently shown that some of these conjectures implying fast matrix multiplication are incompatible with another plausible conjecture, the sunflower conjecture.Alon, Shpilka, Umans, On Sunflowers and Matrix Multiplication Freivalds' algorithm is a simple Monte Carlo algorithm that given matrices  verifies in  time if . Because of the nature of matrix operations and the layout of matrices in memory, it is typically possible to gain substantial performance gains through use of parallelization and vectorization. Several algorithms are possible, among which divide and conquer algorithms based on the block matrix decomposition \mathbf{C} = \begin{pmatrix} \mathbf{C}_{11} & \mathbf{C}_{12} \\ \mathbf{C}_{21} & \mathbf{C}_{22} \\ \end{pmatrix} = \begin{pmatrix} \mathbf{A}_{11} & \mathbf{A}_{12} \\ \mathbf{A}_{21} & \mathbf{A}_{22} \\ \end{pmatrix} \begin{pmatrix} \mathbf{B}_{11} & \mathbf{B}_{12} \\ \mathbf{B}_{21} & \mathbf{B}_{22} \\ \end{pmatrix} = \mathbf{A} \mathbf{B} that also underlies Strassen's algorithm. Here, ,  and  are presumed to be  by  (square) matrices, and   etc. are  by  submatrices. From this decomposition, one derives \begin{pmatrix} \mathbf{A}_{11} & \mathbf{A}_{12} \\ \mathbf{A}_{21} & \mathbf{A}_{22} \\ \end{pmatrix} \begin{pmatrix} \mathbf{B}_{11} & \mathbf{B}_{12} \\ \mathbf{B}_{21} & \mathbf{B}_{22} \\ \end{pmatrix} = \begin{pmatrix} \mathbf{A}_{11} \mathbf{B}_{11} + \mathbf{A}_{12} \mathbf{B}_{21} & \mathbf{A}_{11} \mathbf{B}_{12} + \mathbf{A}_{12} \mathbf{B}_{22}\\ \mathbf{A}_{21} \mathbf{B}_{11} + \mathbf{A}_{22} \mathbf{B}_{21} & \mathbf{A}_{21} \mathbf{B}_{12} + \mathbf{A}_{22} \mathbf{B}_{22}\\ \end{pmatrix}  which consists of eight multiplications of pairs of submatrices, which can all be performed in parallel, followed by an addition step. Applying this recursively, and performing the additions in parallel as well, one obtains an algorithm that runs in  time on an ideal machine with an infinite number of processors, and has a maximum possible speedup of  on any real computer (although the algorithm isn't practical, a more practical variant achieves  speedup). It should be noted that some lower time-complexity algorithms on paper may have indirect time complexity costs on real machines. On modern architectures with hierarchical memory, the cost of loading and storing input matrix elements tends to dominate the cost of arithmetic. On a single machine this is the amount of data transferred between RAM and cache, while on a distributed memory multi-node machine it is the amount transferred between nodes; in either case it is called the communication bandwidth. The naïve algorithm using three nested loops uses  communication bandwidth. Cannon's algorithm, also known as the 2D algorithm, partitions each input matrix into a block matrix whose elements are submatrices of size  by , where  is the size of fast memory.Lynn Elliot Cannon, A cellular computer to implement the Kalman Filter Algorithm, Technical report, Ph.D. Thesis, Montana State University, 14 July 1969. The naïve algorithm is then used over the block matrices, computing products of submatrices entirely in fast memory. This reduces communication bandwidth to , which is asymptotically optimal (for algorithms performing  computation). In a distributed setting with  processors arranged in a  by  2D mesh, one submatrix of the result can be assigned to each processor, and the product can be computed with each processor transmitting  words, which is asymptotically optimal assuming that each node stores the minimum  elements. This can be improved by the 3D algorithm, which arranges the processors in a 3D cube mesh, assigning every product of two input submatrices to a single processor. The result submatrices are then generated by performing a reduction over each row. This algorithm transmits  words per processor, which is asymptotically optimal. However, this requires replicating each input matrix element  times, and so requires a factor of  more memory than is needed to store the inputs. This algorithm can be combined with Strassen to further reduce runtime. "2.5D" algorithms provide a continuous tradeoff between memory usage and communication bandwidth. On modern distributed computing environments such as MapReduce, specialized multiplication algorithms have been developed. Some other ways to multiply two matrices are given below; some, in fact, are simpler than the definition above. The Cracovian product is yet another form. For two matrices of the same dimensions, there is the Hadamard product, also known as the element-wise product, pointwise product, entrywise product and the Schur product. For two matrices  and  of the same dimensions, the Hadamard product  is a matrix of the same dimensions, the  element of  is multiplied with the  element of , that is:  \left(\mathbf{A} \circ \mathbf{B}\right)_{ij} = A_{ij}B_{ij}\,, displayed fully:  \mathbf{A} \circ \mathbf{B} = \begin{pmatrix} A_{11} & A_{12} & \cdots & A_{1m} \\  A_{21} & A_{22} & \cdots & A_{2m} \\ \vdots & \vdots & \ddots & \vdots \\  A_{n1} & A_{n2} & \cdots & A_{nm} \\ \end{pmatrix}\circ\begin{pmatrix}  B_{11} & B_{12} & \cdots & B_{1m} \\  B_{21} & B_{22} & \cdots & B_{2m} \\ \vdots & \vdots & \ddots & \vdots \\  B_{n1} & B_{n2} & \cdots & B_{nm} \\ \end{pmatrix} =\begin{pmatrix}  A_{11}B_{11} & A_{12}B_{12} & \cdots & A_{1m}B_{1m} \\  A_{21}B_{21} & A_{22}B_{22} & \cdots & A_{2m}B_{2m} \\ \vdots & \vdots & \ddots & \vdots \\  A_{n1}B_{n1} & A_{n2}B_{n2} & \cdots & A_{nm}B_{nm} \\ \end{pmatrix} This operation is identical to multiplying many ordinary numbers ( of them) all at once; thus the Hadamard product is commutative, associative and distributive over entrywise addition. It is also a principal submatrix of the Kronecker product. It appears in lossy compression algorithms such as JPEG. The Frobenius inner product, sometimes denoted , often denoted \langle A,B \rangle_F, is the component-wise inner product of two matrices as though they are vectors. It is also the sum of the entries of the Hadamard product. Explicitly, \mathbf{A}:\mathbf{B}=\sum_{i,j} A_{ij} B_{ij} = \mathrm{vec}(\mathbf{A})^\mathsf{T} \mathrm{vec}(\mathbf{B}) = \mathrm{tr}(\mathbf{A}^\mathsf{T} \mathbf{B}) = \mathrm{tr}(\mathbf{A} \mathbf{B}^\mathsf{T}), where "tr" denotes the trace of a matrix and vec denotes vectorization. This inner product induces the Frobenius norm: \|A\|^2_F = \langle A,A \rangle_F. For two matrices  and  of any different dimensions  and  respectively (no constraints on the dimensions of each matrix), the Kronecker product is the matrix  \mathbf{A} \otimes \mathbf{B} = \begin{pmatrix} A_{11}\mathbf{B} & A_{12}\mathbf{B} & \cdots & A_{1n}\mathbf{B} \\  A_{21}\mathbf{B} & A_{22}\mathbf{B} & \cdots & A_{2n}\mathbf{B} \\ \vdots & \vdots & \ddots & \vdots \\  A_{m1}\mathbf{B} & A_{m2}\mathbf{B} & \cdots & A_{mn}\mathbf{B} \\ \end{pmatrix}. with dimensions .. This is the application of the more general tensor product to matrices.      Basic Linear Algebra Subprograms Composition of relations Logical matrix Matrix analysis Matrix inversion Henry Cohn, Robert Kleinberg, Balázs Szegedy, and Chris Umans. Group-theoretic Algorithms for Matrix Multiplication. . Proceedings of the 46th Annual Symposium on Foundations of Computer Science, 23–25 October 2005, Pittsburgh, PA, IEEE Computer Society, pp.&nbsp;379–388. Henry Cohn, Chris Umans. A Group-theoretic Approach to Fast Matrix Multiplication. . Proceedings of the 44th Annual IEEE Symposium on Foundations of Computer Science, 11–14 October 2003, Cambridge, MA, IEEE Computer Society, pp.&nbsp;438–449. Knuth, D.E., The Art of Computer Programming Volume 2: Seminumerical Algorithms. Addison-Wesley Professional; 3 edition (November 14, 1997). ISBN 978-0-201-89684-8. pp.&nbsp;501. . Ran Raz. On the complexity of matrix product. In Proceedings of the thirty-fourth annual ACM symposium on Theory of computing. ACM Press, 2002. . Robinson, Sara, Toward an Optimal Algorithm for Matrix Multiplication, SIAM News 38(9), November 2005. PDF Strassen, Volker, Gaussian Elimination is not Optimal, Numer. Math. 13, p.&nbsp;354-356, 1969. Vassilevska Williams, Virginia, Multiplying matrices faster than Coppersmith-Winograd, Manuscript, May 2012. PDF How to Multiply Matrices Matrix Multiplication Calculator Online The Simultaneous Triple Product Property and Group-theoretic Results for the Exponent of Matrix Multiplication WIMS Online Matrix Multiplier Linear algebra: matrix operations Multiply or add matrices of a type and with coefficients you choose and see how the result was computed. Matrix Multiplication in Java – Dr. P. Viry

   In computer science, computer engineering and programming language implementations, a stack machine is a real or emulated computer that uses a pushdown stack rather than individual machine registers to evaluate each sub-expression in the program.  A stack computer is programmed with a reverse Polish notation instruction set. The common alternative to stack machines are register machines, in which each instruction explicitly names the specific registers to use for operand and result values. A stack machine implements registers with a stack. The operands of the arithmetic logic unit (ALU) are always the top two registers of the stack and the result from the ALU is stored in the top register of the stack. "Stack machine" commonly refers to computers which use a Last-in, First-out stack to hold short-lived temporary values while executing individual program statements.   The instruction set carries out most ALU actions with postfix (Reverse Polish notation) operations that work only on the expression stack, not on data registers or main memory cells. For a typical instruction like Add, both operands implicitly come from the topmost (most recent) values of the stack, and those two values get replaced by the result of the Add.  The instruction's operands are 'popped' off the stack, and its result(s) are then 'pushed' back onto the stack, ready for the next instruction.   Most stack instructions are encoded as just an opcode, with no additional fields to specify a register number or memory address or literal constant.  This encoding is easily extended to richer operations with more than two inputs or more than one result.  Integer constant operands are pushed by separate Load Immediate instructions.  All accessing of program variables in main memory RAM is segregated into separate Load or Store instructions containing one memory address or some way to calculate that address from stacked operands. The stack machine style is in contrast to register file machines that hold temporary values in a small fast visible array of similar registers, accumulator machines that have only one visible general-purpose temp register, belt machines that use a FIFO queue to hold temporaries, and memory-to-memory machines that have no visible temporary registers. Some machines have a stack of very limited size, implemented as a register file and a dynamic register renumbering scheme.  Some machines have a stack of unlimited size, implemented as an array in RAM accessed by a 'top of stack' address register.  Its topmost N values may be cached by invisible data registers for speed.Burroughs large systemsHP 3000 A few machines have both an expression stack in memory and a separate visible register stack. Stack machines may have their expression stack and their call-return stack as separate things or as one integrated structure. Some technical handheld calculators use reverse Polish notation in their keyboard interface, instead of having parenthesis keys.  This is a form of stack machine.  The Plus key relies on its two operands already being at the correct topmost positions of the user-visible stack. Stack machines have much smaller instructions than the other styles of machines.   But operand loads are separate and so stack code requires roughly twice as many instructions as the equivalent code for register machines.  The total code size (in bytes) is still less for stack machines. In stack machine code, the most frequent instructions consist of just an opcode and can easily fit in 6 bits or less.  Branches, load immediates, and load/store instructions require an argument field, but stack machines often arrange that the frequent cases of these still fit together with thin opcode into a single byte or syllable.  The selection of operands from prior results is done implicitly by the ordering of the stack ops.  In contrast, register machines require two or three register-number fields per ALU instruction to select its operands; the densest register machines average about 16 bits per instruction. The instructions for accumulator or memory-to-memory machines are not padded out with multiple register fields.  Instead, they use compiler-managed anonymous variables for subexpression values.  These temps require extra memory reference instructions which take more code space than for the stack machine. All stack machines have variants of the load/store opcodes for accessing local variables and formal parameters without explicit address calculations.  This can be by offsets from the current top-of-stack address, or by offsets from a stable frame-base register.  Register machines handle this with a register+offset address mode, but use a wider offset field. Dense machine code was very valuable in the 1960s, when main memory was very expensive and very limited even on mainframes. It became important again on the initially-tiny memories of minicomputers and then microprocessors. Density remains important today, for smartphone applications, applications downloaded into browsers over slow Internet connections, and in ROMs for embedded applications. A more general advantage of increased density is improved effectiveness of caches and instruction prefetch. Some of the density of Burroughs B6700 code was due to moving vital operand information elsewhere, to 'tags' on every data word or into tables of pointers.  The Add instruction itself was generic or polymorphic.  It had to fetch the operand to discover whether this was an integer add or floating point add.  The Load instruction could find itself tripping on an indirect address, or worse, a disguised call to a call-by-name thunk routine.  The generic opcodes required fewer opcode bits but made the hardware more like an interpreter, with less opportunity to pipeline the common cases. Compilers for stack machines are simpler and quicker to build than compilers for other machines.  Code generation is trivial and independent of prior or subsequent code. For example, given an expression x+y*z+u, the corresponding syntax tree would be: The compiled code for a simple stack machine would take the form: push x   push y   push z   multiply   add   push u   add  Note that the arithmetic operations 'multiply' and 'add' act on the two topmost operands of the stack. Due to its simplicity, such compilation can be easily integrated into the parsing pass.  No register management is needed, and no optimizations for constants or repeated simple memory references are needed (or even allowed).  The same opcode that handles the frequent common case of an add, an indexed load, or a function call will also handle the general case involving complex subexpressions and nested calls. The compiler and the machine need not deal separately with corner cases. This simplicity has allowed compilers to fit onto very small machines.  The simple compilers allowed new product lines to get to market quickly, and allowed new operating systems to be written entirely in a new high level language rather than in assembly.  The UCSD p-System supported a complete student programming environment on early 8-bit microprocessors with poor instruction sets and little RAM, by compiling to a virtual stack machine rather than to the actual hardware. The downside to the simplicity of compilers for stack machines, is that pure stack machines have not benefited much from subsequent advancements in compiler optimizer technology (see subsections in ยง performance disadvantages of stack machines). However optimisation of compiled stack code is quite possible. Back-end optimisation of compiler output has been demonstrated to significantly improve code, and potentially performance, whilst global optimisation within the compiler itself achieves further gains. Some stack machine instruction sets are intended for interpretive execution of a virtual machine, rather than driving hardware directly.  Interpreters for virtual stack machines are easier to build than interpreters for register or memory-to-memory machines; the logic for handling memory address modes is in just one place rather than repeated in many instructions.  Stack machines also tend to have fewer variations of an opcode; one generalized opcode will handle both frequent cases and obscure corner cases of memory references or function call setup.  (But code density is often improved by adding short and long forms for the same operation.) A machine with an expression stack can get by with just two visible registers, the top-of-stack address and the next-instruction address.  The minimal hardware implementation has few bits of flipflops or registers.  Faster implementations buffer the topmost N stack cells into invisible temp registers to reduce memory stack cycles. Responding to an interrupt involves pushing the visible registers and branching to the interrupt handler.  This is faster than storing most or all of the visible registers of a register machine, giving a quicker response to the interrupt.RTX2010  Some register machines deal with this by having multiple register files that can be instantly swapped8051 CPU Manual, Intel, 1980 but this increases its costs and slows down the register file. Some in the industry believe that stack machines execute more data cache cycles for temporary values and local variables than do register machines."Computer Architecture: A Quantitative Approach", John L Hennessy, David A Patterson; See the discussion of stack machines. On stack machines, temporary values often get spilled into memory, whereas on machines with many registers these temps usually remain in registers.  (However, these values often need to be spilled into "activation frames" at the end of a procedure's definition, basic block, or at the very least, into a memory buffer during interrupt processing).  Values spilled to memory add more cache cycles.  This spilling effect depends on the number of hidden registers used to buffer top-of-stack values, upon the frequency of nested procedure calls, and upon host computer interrupt processing rates. Some simple stack machines or stack interpreters use no top-of-stack hardware registers.  Those minimal implementations are always slower than standard register machines.  A typical expression like X+1 compiles to 'Load X; Load 1; Add'.  This does implicit writes and reads of the memory stack which weren't needed: for a total of 5 data cache references. The next step up from this is a stack machine or interpreter with a single top-of-stack register.  The above code then does: for a total of 5 data cache references, worst-case.  Generally, interpreters don't track emptiness, because they don't have toโanything below the stack pointer is a non-empty value, and the TOS cache register is always kept hot.  Typical Java interpreters do not buffer the top-of-stack this way, however, because the program and stack have a mix of short and wide data values. If the hardwired stack machine has N registers to cache the topmost memory stack words, then all spills and refills are avoided in this example and there is only 1 data cache cycle, the same as for a register or accumulator machine. On register machines using optimizing compilers, it is very common for the most-used local variables to live in registers rather than in stack frame memory cells.  This eliminates all data cache cycles for reading and writing those values, except for their initial load and final store upon procedure termination.  The development of 'stack scheduling' for performing live-variable analysis, and thus retaining key variables on the stack for extended periods, goes a long way to answering this concern. On the other hand, register machines must spill many of their registers to memory across nested procedure calls.  The decision of which registers to spill, and when, is made statically at compile time rather than on the dynamic depth of the calls.  This can lead to more data cache traffic than in an advanced stack machine implementation. In register machines, a subexpression which is used multiple times with the same result value can be evaluated just once and its result saved in a fast register. The subsequent reuses have no time or code cost, just a register reference that would have happened anyhow. This optimization wins for common simple expressions (for example, loading variable X or pointer P) as well as less-common complex expressions. With stack machines, in contrast, the results of a subexpression can be stored in one of two ways. The first way involves a temporary variable in memory. Storing and subsequent retrievals cost additional instructions and additional data cache cycles. Doing this is only a win if the subexpression computation costs more in time than fetching from memory, which in most stack CPUs, almost always is the case. It is never worthwhile for simple variables and pointer fetches, because those already have the same cost of one data cache cycle per access. It is only marginally worthwhile for expressions like X+1. These simpler expressions make up the majority of redundant, optimizable expressions in programs written in non-concatenative languages. An optimizing compiler can only win on redundancies that the programmer could have avoided in the source code. The second way involves just leaving a computed value on the data stack, and duplicating it on an as-needed basis. This requires some amount of stack permutation, at the very least, an instruction to duplicate the results. This approach wins only if you can keep your data stack depth shallow enough for a "DUP", "ROT", or "OVER" type of instruction to gain access to the desired computed value. Some virtual machines support a general purpose permutation primitive, "PICK," which allows one to select arbitrarily any item in the data stack for duplication. Despite how limiting this approach sounds, hand-written stack code tends to make extensive use of this approach, resulting in software with runtime overheads comparable to those of general-purpose register-register architectures.http://www.ece.cmu.edu/~koopman/stack_computers/ Stack Computers: the new wave book by Philip J. Koopman, Jr. 1989http://www.eecg.utoronto.ca/~laforest/Second-Generation_Stack_Computer_Architecture.pdf Second-Generation Stack Computer Architecture Unfortunately, algorithms for optimal "stack scheduling" of values aren't known to exist in general, making such stack optimizations difficult to impossible to automate for non-concatenative programming languages. As a result, it is very common for compilers for stack machines to never bother applying code-factoring optimizations. It is too much trouble, despite the significant payoff. In modern machines, the time to fetch a variable from the data cache is often several times longer than the time needed for basic ALU operations.  A program runs faster without stalls if its memory loads can be started several cycles before the instruction which needs that variable, while also working on independent instructions.  Complex machines can do that with a deep pipeline and "out-of-order execution" that examines and runs many instructions at once.  Register machines can also do this with much simpler "in-order" hardware, a shallow pipeline, and slightly smarter compilers.Hennessy, ibid. The load step becomes a separate instruction, and that instruction is statically scheduled much earlier in the code sequence.  The compiler puts independent steps in between. This scheduling trick requires explicit, spare registers.  It is not possible on stack machines without exposing some aspect of the micro-architecture to the programmer.  For the expression A-B, the right operand must be evaluated and pushed immediately prior to the Minus step.  Without stack permutation or hardware multithreading, relatively little useful code can be put in between while waiting for the Load B to finish.  Stack machines can work around the memory delay by either having a deep out-of-order execution pipeline covering many instructions at once, or more likely, they can permute the stack such that they can work on other workloads while the load completes, or they can interlace the execution of different program threads, as in the Unisys A9 system.'Introduction to A Series Systems', Burroughs Corporation, page 41, http://www.bitsavers.org/pdf/burroughs/A-Series/1170057_aSeries_Intro_apr86.pdf  Today's increasingly parallel computational loads suggests, however, this might not be the disadvantage it's been made out to be in the past. Some simple stack machines have a chip design which is fully customized all the way down to the level of individual registers.  The top of stack address register and the N top of stack data buffers are built from separate individual register circuits, with separate adders and ad hoc connections. However, most stack machines are built from larger circuit components where the N data buffers are stored together within a register file and share read/write buses.  The decoded stack instructions are mapped into one or more sequential actions on that hidden register file. Loads and ALU ops act on a few topmost registers, and implicit spills and fills act on the bottommost registers. The decoder allows the instruction stream to be compact.  But if the code stream instead had explicit register-select fields which directly manipulated the underlying register file, the compiler could make better use of all registers and the program would run faster. Microprogrammed stack machines are an example of this.  The inner microcode engine is some kind of RISC-like register machine or a VLIW-like machine using multiple register files.  When controlled directly by task-specific microcode, that engine gets much more work completed per cycle than when controlled indirectly by equivalent stack code for that same task. The object code translators for the HP 3000 and Tandem T/16 are another example.HP3000 Emulation on HP Precision Architecture Computers, Arndt Bergh, Keith Keilman, Daniel Magenheimer, and James Miller, Hewlett-Packard Journal, Dec 1987, p87-89, http://www.hpl.hp.com/hpjournal/pdfs/IssuePDFs/1987-12.pdfMigrating a CISC Computer Family onto RISC via Object Code Translation, K. Andrews and D. Sand, Proceedings of ASPLOS-V, October, 1992 They translated stack code sequences into equivalent sequences of RISC code.  Minor 'local' optimizations removed much of the overhead of a stack architecture.  Spare registers were used to factor out repeated address calculations.  The translated code still retained plenty of emulation overhead from the mismatch between original and target machines. Despite that burden, the cycle efficiency of the translated code matched the cycle efficiency of the original stack code.  And when the source code was recompiled directly to the register machine via optimizing compilers, the efficiency doubled.  This shows that the stack architecture and its non-optimizing compilers were wasting over half of the power of the underlying hardware. Register files are good tools for computing because they have high bandwidth and very low latency, compared to memory references via data caches.  In a simple machine, the register file allows reading two independent registers and writing of a third, all in one ALU cycle with one-cycle or less latency.  Whereas the corresponding data cache can start only one read or one write (not both) per cycle, and the read typically has a latency of two ALU cycles.  That's one third of the throughput at twice the pipeline delay.  In a complex machine like Athlon that completes two or more instructions per cycle, the register file allows reading of four or more independent registers and writing of two others, all in one ALU cycle with one-cycle latency.  Whereas the corresponding dual-ported data cache can start only two reads or writes per cycle, with multiple cycles of latency.  Again, that's one third of the throughput of registers.  It is very expensive to build a cache with additional ports. Interpreters for virtual stack machines are often slower than interpreters for other styles of virtual machine."Virtual Machine Showdown: Stack vs. Register Machine", Yunhe Shi, David Gregg, Andrew Beatty, M. Anton Ertle, http://usenix.org/events/vee05/full_papers/p153-yunhe.pdf This slowdown is worst when running on host machines with deep execution pipelines, such as current x86 chips. A program has to execute more instructions when compiled to a stack machine than when compiled to a register machine or memory-to-memory machine.  Every variable load or constant requires its own separate Load instruction, instead of being bundled within the instruction which uses that value.  The separated instructions may be simple and faster running, but the total instruction count is still higher. In some interpreters, the interpreter must execute a N-way switch jump to decode the next opcode and branch to its steps for that particular opcode. Another method for selecting opcodes is threaded code. The host machine's prefetch mechanisms are unable to predict and fetch the target of that indexed or indirect jump.  So the host machine's execution pipeline must restart each time the hosted interpreter decodes another virtual instruction.  This happens more often for virtual stack machines than for other styles of virtual machine.'The Case for Virtual Register Machines',  Brian Davis, Andrew Beatty, Kevin Casey, David Gregg and John Waldron, http://www.scss.tcd.ie/David.Gregg/papers/Gregg-SoCP-2005.pdf Android's Dalvik virtual machine for Java uses a virtual-register 16-bit instruction set instead of Java's usual 8-bit stack code, to minimize instruction count and opcode dispatch stalls.  Arithmetic instructions directly fetch or store local variables via 4-bit (or larger) instruction fields.  Version 5.0 of Lua replaced its virtual stack machine with a faster virtual register machine. 'The Implementation of Lua 5.0', Ierusalimschy, de Figueiredo, and Celes, http://www.lua.org/doc/jucs05.pdf 'The Virtual Machine of Lua 5.0', Roberto Ierusalimschy, http://www.inf.puc-rio.br/~roberto/talks/lua-ll3.pdf (These should not be confused with hybrid computers that combine both digital and analogue features, e.g. an otherwise digital computer that accesses analogue multiplication or differential equation solving by memory mapping and conversion to and from an analogue device's inputs and outputs.) Pure stack machines are quite inefficient for procedures which access multiple fields from the same object. The stack machine code must reload the object pointer for each pointer+offset calculation. A common fix for this is to add some register-machine features to the stack machine: a visible register file dedicated to holding addresses, and register-style instructions for doing loads and simple address calculations. It is uncommon to have the registers be fully general purpose, because then there is no strong reason to have an expression stack and postfix instructions. Another common hybrid is to start with a register machine architecture, and add another memory address mode which emulates the push or pop operations of stack machines: 'memaddress = reg; reg += instr.displ'. This was first used in DEC's PDP-11 minicomputer. This feature was carried forward in VAX computers and in Motorola 6800 and M68000 microprocessors. This allowed the use of simpler stack methods in early compilers. It also efficiently supported virtual machines using stack interpreters or threaded code. However, this feature did not help the register machine's own code to become as compact as pure stack machine code. Also, the execution speed was less than when compiling well to the register architecture. It is faster to change the top-of-stack pointer only occasionally (once per call or return) rather than constantly stepping it up and down throughout each program statement, and it is even faster to avoid memory references entirely. More recently, so-called second-generation stack machines have adopted a dedicated collection of registers to serve as address registers, off-loading the task of memory addressing from the data stack. For example, MuP21 relies on a register called "A", while the more recent GreenArrays processors relies on two registers: A and B. The Intel x86 family of microprocessors have a register-style (accumulator) instruction set for most operations, but use stack instructions for its x87, Intel 8087 floating point arithmetic, dating back to the iAPX87 (8087) coprocessor for the 8086 and 8088. That is, there are no programmer-accessible floating point registers, but only an 80-bit wide, 8 deep stack. The x87 relies heavily on the x86 CPU for assistance in performing its operations. Examples of stack instruction sets directly executed in hardware include http://www.atmel.com/dyn/resources/prod_documents/doc4747.pdf 'Porting the GNU C Compiler to the Thor Microprocessor', Harry Gunnarsson and Thomas Lundqvist, http://lundqvist.dyndns.org/Publications/thesis95/ThorGCC.pdf Examples of virtual stack machines interpreted in software: Most current computers (of any instruction set style) and most compilers use a large call-return stack in memory to organize the short-lived local variables and return links for all currently active procedures or functions.  Each nested call creates a new stack frame in memory, which persists until that call completes.  This call-return stack may be entirely managed by the hardware via specialized address registers and special address modes in the instructions.  Or it may be merely a set of conventions followed by the compilers, using generic registers and register+offset address modes.  Or it may be something in between. Since this technique is now nearly universal, even on register machines, it is not helpful to refer to all these machines as stack machines.  That term is commonly reserved for machines which also use an expression stack and stack-only arithmetic instructions to evaluate the pieces of a single statement. Computers commonly provide direct, efficient access to the program's global variables and to the local variables of only the current innermost procedure or function, the topmost stack frame.  'Up level' addressing of the contents of callers' stack frames is usually not needed and not supported as directly by the hardware.  If needed, compilers support this by passing in frame pointers as additional, hidden parameters. Some Burroughs stack machines do support up-level refs directly in the hardware, with specialized address modes and a special 'display' register file holding the frame addresses of all outer scopes.  No subsequent computer lines have done this in hardware.  When Niklaus Wirth developed the first Pascal compiler for the CDC 6000, he found that it was faster overall to pass in the frame pointers as a chain, rather than constantly updating complete arrays of frame pointers.  This software method also adds no overhead for common languages like C which lack up-level refs. The same Burroughs machines also supported nesting of tasks or threads.  The task and its creator share the stack frames that existed at the time of task creation, but not the creator's subsequent frames nor the task's own frames.  This was supported by a cactus stack, whose layout diagram resembled the trunk and arms of a Saguaro cactus.  Each task had its own memory segment holding its stack and the frames that it owns.  The base of this stack is linked to the middle of its creator's stack.  In machines with a conventional flat address space, the creator stack and task stacks would be separate heap objects in one heap. In some programming languages, the outer-scope data environments are not always nested in time.  These languages organize their procedure 'activation records' as separate heap objects rather than as stack frames appended to a linear stack. In simple languages like Forth that lack local variables and naming of parameters, stack frames would contain nothing more than return branch addresses and frame management overhead.  So their return stack holds bare return addresses rather than frames.  The return stack is separate from the data value stack, to improve the flow of call setup and returns. Load X, push to memory Load 1, push to memory Pop 2 values from memory, add, and push result to memory Load X into empty TOS register (if hardware machine), or Push TOS register to memory, Load X into TOS register (if interpreter) Push TOS register to memory, Load 1 into TOS register Pop left operand from memory, add to TOS register and leave it there The F18A architecture of the 144-processor GA144 chip from GreenArrays, Inc."GreenArrays, Inc. Documentation: sections on Architecture, F18A Technology and Chips using F18A Technology""Instruction set of the F18A cores (named  colorForth for historical reasons).""GreenArrays, Inc." the Burroughs large systems architecture (since 1961) the English Electric KDF9 machine. Introduced 1964, the KDF9 had a 16-deep pushdown stack of arithmetic registers, and a similar stack for subroutine return addresses the Collins Radio Collins Adaptive Processing System minicomputer (CAPS, since 1969) and Rockwell Collins Advanced Architecture Microprocessor (AAMP, since 1981)."The World's First Java Processor", by David A. Greve and Matthew M. Wilding, Electronic Engineering Times, Jan. 12, 1998, the UCSD Pascal p-machine (as the Pascal MicroEngine and many others) MU5 and ICL 2900 Series.  Hybrid stack and accumulator machines.  The accumulator register buffered the memory stack's top data value.  Variants of load and store opcodes controlled when that register was spilled to the memory stack or reloaded from there. HP 3000 (Classic, not PA-RISC) Tandem Computers T/16.  Like HP 3000, except that compilers, not microcode, controlled when the register stack spilled to the memory stack or was refilled from the memory stack. the Atmel MARC4 microcontroller'MARC4 4-bit Microcontrollers Programmers Guide', Atmel, Several "Forth chips"Forth chips such as the RTX2000, the RTX2010, the F21F21 Microprocessor Overview and the PSC1000PSC1000 Microprocessor Reference Manual, Patriot Scientific Corporation, http://www.forthfreak.net/misc/psc1000.pdf[http://www.developer.com/java/other/article.php/610041 A Java chip available &mdash; now!], by Rick Brian Slack The 4stack processor by Bernd Paysan has four stacks.4stack Processor Patriot Scientific's Ignite stack machine designed by Charles H. Moore holds a leading functional density benchmark. Saab Ericsson Space Thor radiation hardened microprocessor Inmos transputers. ZPU A physically-small CPU designed to supervise FPGA systems. the UCSD Pascal p-machine (which closely resembled Burroughs) the Java virtual machine instruction set the VES (Virtual Execution System) for the CIL (Common Intermediate Language) instruction set of the ECMA 335 (Microsoft .NET environment) the Forth programming language, in particular the Forth virtual machine Adobe's PostScript Parakeet programming language Sun Microsystems' SwapDrop programming language for Sun Ray smartcard identification Adobe's AVM2 Ethereum's EVM the CPython bytecode interpreter the Ruby YARV bytecode interpreter the Rubinius Virtual Machine Stack-oriented programming language Concatenative programming language Comparison of application virtual machines Stack Computers: the new wave book by Philip J. Koopman, Jr. 1989 Homebrew CPU in an FPGA &mdash; homebrew stack machine using FPGA Mark 1 FORTH Computer &mdash; homebrew stack machine using discrete logical circuits Mark 2 FORTH Computer &mdash; homebrew stack machine using bitslice/PLD Second-Generation Stack Computer Architecture &mdash; Thesis about the history and design of stack machines.

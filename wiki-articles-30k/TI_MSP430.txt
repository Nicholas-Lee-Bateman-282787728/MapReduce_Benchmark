   The MSP430 is a mixed-signal microcontroller family from Texas Instruments. Built around a  CPU, the MSP430 is designed for low cost and, specifically, low power consumptionMSP430 will run on grapes - video on YouTube embedded applications. The MSP430 can be used for low powered embedded devices. The current drawn in idle mode can be less than 1&nbsp;µA. The top CPU speed is 25&nbsp;MHz. It can be throttled back for lower power consumption. The MSP430 also uses six different low-power modes, which can disable unneeded clocks and CPU. Additionally, the MSP430 is capable of wake-up times below 1 microsecond, allowing the microcontroller to stay in sleep mode longer, minimizing its average current consumption. The device comes in a variety of configurations featuring the usual peripherals: internal oscillator, timer including PWM, watchdog, USART, SPI, I²C, 10/12/14/16/24-bit ADCs, and brownout reset circuitry. Some less usual peripheral options include comparators (that can be used with the timers to do simple ADC), on-chip op-amps for signal conditioning, 12-bit DAC, LCD driver, hardware multiplier, USB, and DMA for ADC results. Apart from some older EPROM (MSP430E3xx) and high volume mask ROM (MSP430Cxxx) versions, all of the devices are in-system programmable via JTAG (full four-wire or Spy-Bi-Wire) or a built in bootstrap loader (BSL) using UART such as RS232, or USB on devices with USB support. There are, however, limitations that preclude its use in more complex embedded systems. The MSP430 does not have an external memory bus, so it is limited to on-chip memory (up to 512&nbsp;KB flash memory and 66&nbsp;KB RAM) which may be too small for applications that require large buffers or data tables. Also, although it has a DMA controller, it is very difficult to use it to move data off the chip due to a lack of a DMA output strobe.D. Peters, D. Raskovic, and D. Thorsen, "An Energy Efficient Parallel Embedded System for Small Satellite Applications", ISAST Transactions on Computers and Intelligent Systems, vol. 1(2), 2009  An MSP430 part number such as "MSP430F2618ATZQWT-EP" consists of the following pieces: Trailing suffix letters indicate options not visible to software: There are six general generations of MSP430 processors. In order of development, they were the '3xx generation, the '1xx generation, the '4xx generation, the '2xx generation, the '5xx generation, and the '6xx generation. The digit after the generation identifies the model (generally higher model numbers are larger and more capable), the third digit identifies the amount of memory on board, and the fourth, if present, identifies a minor model variant. The most common variation is a different on-chip analog-to-digital converter. The 3xx and 1xx generations were limited to a 16-bit address space. In the later generations this was expanded to include '430X' instructions that allow a 20-bit address space. As happened with other processor architectures (e.g. the processor of the PDP-11), extending the addressing range beyond the 16-bit word size introduced some peculiarities and inefficiencies for programs larger than 64&nbsp;kBytes. In the following list, it helps to think of the typical 200&nbsp;mA·Hr capacity of a CR2032 lithium coin cell as 200,000&nbsp;μA·Hr, or 22.8&nbsp;μA·year.  Thus, considering only the CPU draw, such a battery could supply a 0.7&nbsp;μA current draw for 32 years. (In reality, battery self-discharge would reduce this number.) The significance of the 'RAM retention' vs the 'real-time clock mode' is that in real time clock mode the CPU can go to sleep with a clock running which will wake it up at a specific future time.  In RAM retention mode, some external signal is required to wake it, e.g. I/O pin signal or SPI slave receive interrupt. The MSP430x1xx Series  is the basic generation without an embedded LCD controller. They are generally smaller than the '3xx generation. These flash- or ROM-based ultra-low-power MCUs offer 8 MIPS, 1.8–3.6&nbsp;V operation, up to 60 KB flash, and a wide range of analog and digital peripherals. *Power specification overview, as low as: **0.1&nbsp;μA RAM retention **0.7&nbsp;μA real-time clock mode **200&nbsp;μA / MIPS active **Features fast wake-up from standby mode in less than 6&nbsp;µs. *Device parameters **Flash options: 1–60 KB **ROM options: 1–16 KB **RAM options: 128 B–10 KB **GPIO options: 14, 22, 48 pins **ADC options: Slope, 10 & 12-bit SAR **Other integrated peripherals: 12-bit DAC, up to 2 16-bit timers, watchdog timer, brown-out reset, SVS, USART module (UART, SPI), DMA, 16×16 multiplier, Comparator_A, temperature sensor The MSP430F2xx Series are similar to the '1xx generation, but operate at even lower power, support up to 16&nbsp;MHz operation, and have a more accurate (±2%) on-chip clock that makes it easier to operate without an external crystal. These flash-based ultra-low power devices offer 1.8–3.6&nbsp;V operation. Includes the very-low power oscillator (VLO), internal pull-up/pull-down resistors, and low-pin count options. *Power specification overview, as low as: **0.1&nbsp;μA RAM retention **0.3&nbsp;μA standby mode (VLO) **0.7&nbsp;μA real-time clock mode **220&nbsp;μA / MIPS active **Feature ultra-fast wake-up from standby mode in less than 1&nbsp;μs *Device parameters **Flash options: 1–120&nbsp;KB **RAM options: 128&nbsp;B – 8&nbsp;KB **GPIO options: 10, 11, 16, 24, 32, and 48 pins **ADC options: Slope, 10 & 12-bit SAR, 16 & 24-bit Sigma Delta **Other integrated peripherals: operational amplifiers, 12-bit DAC, up to 2 16-bit timers, watchdog timer, brown-out reset, SVS, USI module (I²C, SPI), USCI module, DMA, 16×16 multiplier, Comparator_A+, temperature sensor The MSP430G2xx Value Series features flash-based Ultra-Low Power MCUs up to 16 MIPS with 1.8–3.6 V operation. Includes the Very-Low power Oscillator (VLO), internal pull-up/pull-down resistors, and low-pin count options, at lower prices than the MSP430F2xx series. *Ultra-Low Power, as low as (@2.2&nbsp;V): **0.1&nbsp;μA RAM retention **0.4&nbsp;μA Standby mode (VLO) **0.7&nbsp;μA real-time clock mode **220&nbsp;μA / MIPS active **Ultra-Fast Wake-Up From Standby Mode in  Lowest Power MSP430 Microcontrollers from Texas Instruments *Power specification overview, as low as: **0.1&nbsp;μA RAM retention **2.5&nbsp;μA real-time clock mode **165&nbsp;μA / MIPS active **Features fast wake-up from standby mode in less than 5&nbsp;µs. *Device parameters: **Flash options: up to 512 KB **RAM options: up to 66 KB **ADC options: 10 & 12-bit SAR **GPIO options: 29, 31, 47, 48, 63, 67, 74, 87 pins **Other integrated peripherals: High resolution PWM, 5&nbsp;V I/O's, USB, backup battery switch, up to 4 16-bit timers, watchdog timer, Real-Time Clock, brown-out reset, SVS, USCI module, DMA, 32x32 multiplier, Comp B, temperature sensor The MSP430x6xx Series are able to run up to 25&nbsp;MHz, have up to 512 KB flash memory and up to 66 KB RAM. This flash-based family features low active power consumption with up to 25 MIPS at 1.8–3.6 V operation (165 uA/MIPS). Includes an innovative power management module for optimal power consumption and integrated USB. *Power specification overview, as low as: **0.1&nbsp;μA RAM retention **2.5&nbsp;μA real-time clock mode **165&nbsp;μA / MIPS active **Features fast wake-up from standby mode in less than 5&nbsp;µs. *Device parameters: **Flash options: up to 512 KB **RAM options: up to 66 KB **ADC options: 12-bit SAR **GPIO options: 74 pins **Other integrated peripherals: USB, LCD, DAC, Comparator_B, DMA, 32x32 multiplier, power management module (BOR, SVS, SVM, LDO), watchdog timer, RTC, Temp sensor The RF SoC (CC430) Series provides tight integration between the microcontroller core, peripherals, software, and RF transceiver. Features  The reference cited uses an obscure timer mode to generate high speed strobes for DMA transfers. Unfortunately, the timers are not flexible enough to easily make up for the lack of an external DMA transfer strobe.  :DMA operations that involve word transfers to byte locations cause truncation to 8 bits rather than conversion to two byte transfers. This makes DMA with A/D or D/A 16 bit values less useful than it could be (although it is possible to DMA these values through port A or B on some versions of the MSP 430 using an externally visible trigger per transfer such as a timer output). *;Enhanced Emulation Module (EEM) :The EEM provides different levels of debug features such as 2-8 hardware breakpoints, complex breakpoints, break when read/write occurs at specified address, and more. Embedded into all flash-based MSP430 devices. *;Hardware multiplier :Some MSP430 models include a memory-mapped hardware multiplier peripheral which performs various 16×16+32→33-bit multiply-accumulate operations. Unusually for the MSP430, this peripheral does include an implicit 2-bit write-only register, which makes it effectively impossible to context switch. This peripheral does not interfere with CPU activities and can be accessed by the DMA. The MPY on all MSP430F5xx and some MSP430F4xx devices feature up to 32-bit x 32-bit. :The 8 registers used are: :{|class="wikitable" |- ! Address || Name || Function |- | 0x130 || MPY || Operand1 for unsigned multiply |- | 0x132 || MPYS || Operand1 for signed multiply |- | 0x134 || MAC || Operand1 for unsigned multiply-accumulate |- | 0x136 || MACS || Operand1 for signed multiply-accumulate |- | 0x138 || OP2 || Second operand for multiply operation |- | 0x13A || ResLo || Low word of multiply result |- | 0x13C || ResHi || High word of multiply result |- | 0x13E || SumExt || Carry out of multiply-accumulate |} :The first operand is written to one of four 16-bit registers. The address written determines the operation performed. While the value written can be read back from any of the registers, the register number written to cannot be recovered. :If a multiply-accumulate operation is desired, the ResLo and ResHi registers must also be initialized. :Then, each time a write is performed to the OP2 register, a multiply is performed and the result stored or added to the result registers. The SumExt register is a read-only register that contains the carry out of the addition (0 or 1) in case of an unsigned multiply), or the sign extension of the 32-bit sum (0 or -1) in case of a signed multiply. In the case of a signed multiply-accumulate, the SumExt value must be combined with the most significant bit of the prior SumHi contents to determine the true carry out result (-1, 0, or +1). :The result is available after three clock cycles of delay, which is the time required to fetch a following instruction and a following index word. Thus, the delay is typically invisible. An explicit delay is only required if using an indirect addressing mode to fetch the result. *;Memory Protection Unit (MPU) :The FRAM MPU protects against accidental writes to designated read-only memory segments or execution of code from a constant memory.  The MPU can set any portioning of memory with bit level addressing, making the complete memory accessible for read, write and execute operations in FRAM devices. *;Power management module (PMM) :The PMM generates a supply voltage for the core logic, and provides several mechanisms for the supervision and monitoring of both the voltage applied to the device and the voltage generated for the core. It is integrated with a low-dropout voltage regulator (LDO), brown-out reset (BOR), and a supply voltage supervisor and monitor. *;Supply-Voltage Supervisor (SVS) :The SVS is a configurable module used to monitor the AVCC supply voltage or an external voltage. The SVS can be configured to set a flag or generate a power-on reset (POR) when the supply voltage or external voltage drops below a user-selected threshold. *;Capacitive Touch Sense I/Os :The integrated capacitive touch sense I/O module offers several benefits to touch button and touch slider applications. The system does not require external components to create the self-oscillation (reducing bill of materials) and the capacitor (that defines the frequency of the self-oscillation) can be connected directly.  In addition, there is no need for external MUXes to allow multiple pads and each I/O pad can directly serve as a cap sense input. A hysteresis of ~0.7&nbsp;V ensures robust operation. Control and sequencing is done completely in software. *;General Purpose I/Os :MSP430 devices have up to 12 digital I/O ports implemented. Each port has eight I/O pins. Every I/O pin can be configured as either input or output, and can be individually read or written to. Ports P1 and P2 have interrupt capability. MSP430F2xx, F5xx and some F4xx devices feature built-in, individually configurable pull-up or pull-down resistors. *;Sub-GHz RF Front End :The flexible CC1101 sub-1&nbsp;GHz transceiver delivers the sensitivity and blocking performance required to achieve successful communication links in any RF environment. It also features low current consumption and supports flexible data rates and modulation formats. *;USART (UART, SPI, I²C) :The universal synchronous/asychrnous receive/transmit (USART) peripheral interface supports asynchronous RS-232 and synchronous SPI communication with one hardware module. The MSP430F15x/16x USART modules also support I²C, programmable baud rate, and independent interrupt capability for receive and transmit. *;USB :The USB module is fully compliant with the USB 2.0 specification and supports control, interrupt and bulk transfers at a data rate of 12 Mbps (full speed). The module supports USB suspend, resume and remote wake-up operations and can be configured for up to eight input and eight output endpoints. The module includes an integrated physical interface (PHY); a phase-locked loop (PLL) for USB clock generation; and a flexible power-supply system enabling bus-powered and self-powered devices. *;USCI (UART, SPI, I²C, LIN, IrDA) :The universal serial communication interface (USCI) module features two independent channels that can be used simultaneously. The asynchronous channel (USCI_A) supports UART mode; SPI mode; pulse shaping for IrDA; and automatic baud-rate detection for LIN communications. The synchronous channel (USCI_B) supports I²C and SPI modes. *;USI (SPI, I²C) :The universal serial interface (USI) module is a synchronous serial communication interface with a data length of up to 16-bits and can support SPI and I²C communication with minimal software. *;Infrared Modulation :Available on the MSP430FR4xxx and MSP430FR2xxx series chips, this feature is configured via the SYSCFG register set.  This peripheral ties in to other peripherals (Timers, eUSCI_A) to generate an IR modulated signal on an output pin.http://www.ti.com/lit/slau445 (page 43) *;ESP430 (integrated in FE42xx devices) :The ESP430CE module performs metering calculations independent of the CPU. Module has separate SD16, HW multiplier, and the ESP430 embedded processor engine for single-phase energy-metering applications. *;Scan Interface (SIF) :The SIF module, a programmable state machine with an analog front end, is used to automatically measure linear or rotational motion with the lowest possible power consumption. The module features support for different types of LC and resistive sensors and for quadrature encoding. *;LCD/LCD_A/LCD_B :The LCD/LCD_A controller directly drives LCDs for up to 196 segments. Supports static, 2-mux, 3-mux, and 4-mux LCDs. LCD_A module has integrated charge pump for contrast control. LCD_B enables blinking of individual segments with separate blinking memory. *;LCD_E :The LCD_E controller comes with the newer MSP430FR4xxx series microcontrollers and directly drives LCDs up to 448 segments.  Supports static, 2-mux, 3-mux, 4-mux, 5-mux, 6-mux, 7-mux, 8-mux (1/3 bias) LCDs.  Segment and Common pins may be reprogrammed to available LCD drive pins.  This peripheral may be driven in LPM3.5 (RTC running+Main CPU core shutdown low-power mode). Texas Instruments provides various hardware experimenter boards that support large (approximately two centimeters square) and small (approximately one millimeter square) MSP430 chips. TI also provides software development tools, both directly, and in conjunction with partners (see the full list of compilers, assemblers, and IDEs). One such toolchain is the IAR C/C++ compiler and Integrated development environment, or IDE. A Kickstart edition can be downloaded for free from TI or IAR; it is limited to 8 KB of C/C++ code in the compiler and debugger (assembly language programs of any size can be developed and debugged with this free toolchain). TI also combines a version of its own compiler and tools with its Eclipse-based Code Composer Studio IDE ("CCS").  It sells full-featured versions, and offers a free version for download which has a code size limit of 16 KB.  CCS supports in-circuit emulators, and includes a simulator and other tools; it can also work with other processors sold by TI. For those who are more comfortable with the Arduino, there is also another software Energia, an open source electronics prototyping platform with the goal to bring the Wiring and Arduino framework to the Texas Instruments MSP430 based LaunchPad where Arduino code can be exported for programming MSP430 chips. The latest release of Energia supports the MSP-EXP430G2xxx, MSP-EXP430FR5739, MSP-EXP430FR5969, MSP-EXP430F5529LP, Stellaris EK-LM4F120XL, Tiva-C EK-TM4C123GXL, Tiva-C EK-TM4C1294XL, CC3200 WiFi LaunchPad.[ ], Energia website The open source community produces a freely available software development toolset based on the GNU toolset. The GNU compiler is currently declined in three versions: (MSPGCC) (MSPGCC Uniarch) TI consulted with RedHat to provide official support for the MSP430 architecture to the GNU Compiler Collection C/C++ compiler.  This msp430-elf-gcc compiler is supported by TI's Code Composer Studio version 6.0 and higher. There is a very early llvm-msp430 project, which may eventually provide better support for MSP430 in LLVM. Other commercial development tool sets, which include editor, compiler, linker, assembler, debugger and in some cases code wizards, are available. VisSim, a block diagram language for model based development, generates efficient fixed point C-Code directly from the diagram.MSP430 article published in IEEE magazine. VisSim generated code for a closed loop ADC+PWM based PID control on the F2013 compiles to less than 1 KB flash and 100 bytes RAM.Visual Solutions VisSim has on-chip peripheral blocks for the entire MSP430 family I²C, ADC, SD16, PWM. The MSP430F2013 and its siblings are set apart by the fact that (except for the MSP430G2 Value Line) it is the only MSP430 part that is available in a dual in-line package (DIP). Other variants in this family are only available in various surface-mount packages. TI has gone to some trouble to support the eZ430 development platform by making the raw chips easy for hobbyists to use in prototypes. TI has tackled the low-budget problem by offering a very small experimenter board, the eZ430-F2013, on a USB stick. This makes it easy for designers to choose the MSP430 chip for inexpensive development platforms that can be used with a computer. The eZ430-F2013 contains an MSP430F2013 microcontroller on a detachable prototyping board, and accompanying CD with development software. It is helpful for schools, hobbyists and garage inventors. It is also welcomed by engineers in large companies prototyping projects with capital budget problems. Texas Instruments released the MSP430 Launchpad in July 2010.  The MSP430 Launchpad has an onboard flash emulator, USB, 2 programmable LEDs, and 1 programmable push button.MSP430 LaunchPad (MSP-EXP430G2), Texas Instruments Embedded Processors Wiki TI has since provided several new LaunchPads based on the MSP430 platform: * MSP-EXP430F5529LP features the MSP430F5529 USB device-capable MCU with 128KB flash and 8KB SRAM * MSP-EXP430FR5969 features the MSP430FR5969 FRAM MCU with 64KB FRAM and 2KB SRAM * MSP-EXP430FR4133 features the MSP430FR4133 FRAM MCU with 16KB FRAM, 2KB SRAM and on-board LCD All three of these LaunchPads include an eZ-FET JTAG debugger with backchannel UART capable of 1Mbit/s speeds.  The FRAM LaunchPads (MSP-EXP430FR5969, MSP-EXP430FR4133) include EnergyTrace, a feature supported by TI's Code Composer Studio IDE for monitoring and analyzing power consumption. In common with other microcontroller vendors, TI has developed a two-wire debugging interface found on some of their MSP430 parts that can replace the larger JTAG interface. The eZ430 Development Tool contains a full USB-connected flash emulation tool ("FET") for this new two-wire protocol, named "Spy-Bi-Wire" by TI. Spy-Bi-Wire was initially introduced on only the smallest devices in the 'F2xx family with limited number of I/O pins, such as the MSP430F20xx, MSP430F21x2, and MSP430F22x2. The support for Spy-Bi-Wire has been expanded with the introduction of the latest '5xx family, where all devices have support Spy-Bi-Wire interface in addition to JTAG. The advantage of the Spy-Bi-Wire protocol is that it uses only two communication lines, one of which is the dedicated _RESET line. The JTAG interface on the lower pin count MSP430 parts is multiplexed with general purpose I/O lines.  This makes it relatively difficult to debug circuits built around the small, low-I/O-budget chips, since the full 4-pin JTAG hardware will conflict with anything else connected to those I/O lines. This problem is alleviated with the Spy-Bi-Wire-capable chips, which are still compatible with the normal JTAG interface for backwards compatibility with the old development tools. JTAG debugging and flash programming tools based on OpenOCD and widely used in the ARM community are not available for the MSP430. Programming tools specially designed for the MSP430 are marginally less expensive than JTAG interfaces that use OpenOCD. However, should a project discover midstream that more MIPS, more memory, and more I/O peripherals are needed, those tools will not transfer to a processor from another vendor. The MSP430 CPU uses a von Neumann architecture, with a single address space for instructions and data. Memory is byte-addressed, and pairs of bytes are combined little-endian to make 16-bit words. The processor contains 16 16-bit registers, of which 4 are dedicated to special purposes: R0 is the program counter, R1 is the stack pointer, R2 is the status register, and R3 is a special register called the constant generator, providing access to 6 commonly used constant values without requiring an additional operand. R3 always reads as 0 and writes to it are ignored. R4 through R15 are available for general use. The instruction set is very simple; there are 27 instructions in three families. Most instructions are available in .B (8-bit byte) and .W (16-bit word) suffixed versions, depending on the value of a B/W bit: the bit is set to 1 for 8-bit and 0 for 16-bit.  A missing suffix is equivalent to .W.  Byte operations to memory affect only the addressed byte, while byte operations to registers clear the most significant byte. Instructions are 16 bits, followed by up to two 16-bit extension words. Addressing modes are specified by the 2-bit As field and the 1-bit Ad field. Some special versions can be constructed using R0, and modes other than register direct using R2 (the status register) and R3 (the constant generator) are interpreted specially. Ad can use only a subset of the addressing modes for As. Indexed addressing modes add a 16-bit extension word to the instruction. If both source and destination are indexed, the source extension word comes first.  x refers to the next extension word in the instruction stream in the table below. Instructions generally take 1 cycle per word fetched or stored, so instruction times range from 1 cycle for a simple register-register instruction to 6 cycles for an instruction with both source and destination indexed. The MSP430X extension with 20-bit addressing adds additional instructions that can require up to 10 clock cycles. Setting or clearing a peripheral bit takes two clocks. A jump, taken or not takes two clocks. With the 2xx series 2 MCLKs is 125 ns at 16&nbsp;MHz. Moves to the program counter are allowed and perform jumps. Return from subroutine, for example, is implemented as MOV @SP+,PC. When R0 (PC) or R1 (SP) are used with the autoincrement addressing mode, they are always incremented by two. Other registers (R4 through R15) are incremented by the operand size, either 1 or 2 bytes. The status register contains 4 arithmetic status bits, a global interrupt enable, and 4 bits that disable various clocks to enter low-power mode. When handling an interrupt, the processor saves the status register on the stack and clears the low-power bits. If the interrupt handler does not modify the saved status register, returning from the interrupt will then resume the original low-power mode. A number of additional instructions are implemented as aliases for forms of the above.  For example, there is no specific "return from subroutine" instruction, but it is implemented as "MOV @SP+,PC".  Emulated instructions are: Note that the immediate constants −1 (0xffff), 0, 1, 2, 4 and 8 can be specified in a single-word instruction without needing a separate immediate operand. The basic MSP430 cannot support more memory (ROM + RAM + peripherals) than its 64K address space.  In order to support this, an extended form of the MSP430 uses 20-bit registers and a 20-bit address space, allowing up to 1 MB of memory.  This uses the same instruction set as the basic form, but with two extensions: The extended instructions include some additional capabilities, notably multi-bit shifts and multi-register load/store operations. 20-bit operations use the length suffix ".A" (for address) instead of .B or .W.  .W is still the default.  In general, shorter operations clear the high-order bits of the destination register. The new instructions are as follows: All other instructions can have a prefix word added which extends them to 20 bits.  The prefix word contains an additional operand size bit, which is combined with the existing B/W bit to specify the operand size.  There is one unused size combination; there are indications that this might be used in future for a 32-bit operand size.The size bit itself is named "A/L", where "L" (long) is used by other processors to indicate 32-bit operands.  Also the description of the SXTX instruction (MSP430F5xx Family User's Guide alau208f page 237) describes the effect of the instruction in register bits 20–31. The prefix word comes in two formats, and the choice between them depends on the instruction which follows. If the instruction has any non-register operands, then the simple form is used, which provides 2 4-bit fields to extend any offset or immediate constant in the instruction stream to 20 bits. If the instruction is register-to-register, a different extension word is used.  This includes a "ZC" flag which suppresses carry-in (useful for instructions like DADD which always use the carry bit), and a repeat count.  A 4-bit field in the extension word encodes either a repeat count (0–15 repetitions in addition to the initial execution), or a register number which contains a 4-bit repeat count. The general layout of the MSP430 address space is: A few models include more than 2048 bytes of RAM; in that case RAM begins at 0x1100. The first 2048 bytes (0x1100–0x18FF) is mirrored at 0x0200–0x09FF for compatibility. Also, some recent models bend the 8-bit and 16-bit peripheral rules, allowing 16-bit access to peripherals in the 8-bit peripheral address range. There is a new extended version of the architecture (called MSP430X) which allows a 20-bit address space. It allows additional program ROM beginning at 0x10000. The '5xx series has a greatly redesigned address space, with the first 4K devoted to peripherals, and up to 16K of RAM. *TI Code Composer Studio IDE, Microcontroller Core Edition (size limited to 16&nbsp;KB) *IAR Embedded Workbench Kickstart IDE (size limited to 4/8/16&nbsp;KB - depends on device used) *GCC toolchain for the MSP430 Microcontrollers *MSP430 Development System *naken_asm Open-Source MSP430 assembler, disassembler, simulator. *Pre-built MSP430 GCC 4.x binaries for Windows *IAR Embedded Workbench for TI MSP430 *TI Code Composer Studio (CCS) Microcontroller or Platinum editions *Rowley CrossWorks for MSP430 (only a 30-day evaluation period) *GCC toolchain for the MSP430 Microcontrollers (Free C-compiler) *MSP430 Development System *A plugin for Visual Studio that supports MSP430 via MSP430-GCC (30-day evaluation) *AQ430 Development Tools for MSP430 Microcontrollers *ImageCraft C Tools *ForthInc Forth-Compiler *MPE Forth IDE & Cross-Compiler for MSP430 currently in Beta *HI-TECH C for MSP430 (Dropped MSP430 Support in 2009) Suffix !! RAM !! ROM Suffix !! RAM !! ROM 0 128 1 K 10 5 K 32 K 1 128 2 K 11 10 K 48 K 2 256 4 K 12 5 K 55/56 K 3 256 8 K 13 4 512 12 K 14 5 512 16 K 15 6 1 K 24 K 16 4 K 92 K 7 1 K 32 K 17 8 K 92 K 8 2 K 48K 18 8 K 116 K 9 2 K 60K 19 4 K 120 K 15 !!width=15pt| 14 !!width=15pt| 13 !!width=15pt| 12 11 !!width=15pt| 10 !!width=15pt| 9 !!width=15pt| 8 7 !!width=15pt| 6 !!width=15pt| 5 !!width=15pt| 4 3 !!width=15pt| 2 !!width=15pt| 1 !!width=15pt| 0 !! Instruction 0 0 0 1 0 0 opcode B/W As register Single-operand arithmetic 0 0 0 1 0 0 0 0 0 B/W As register RRC Rotate right (1 bit) through carry 0 0 0 1 0 0 0 0 1 0 As register SWPB Swap bytes 0 0 0 1 0 0 0 1 0 B/W As register RRA Rotate right (1 bit) arithmetic 0 0 0 1 0 0 0 1 1 0 As register SXT Sign extend byte to word 0 0 0 1 0 0 1 0 0 B/W As register PUSH Push value onto stack 0 0 0 1 0 0 1 0 1 0 As register CALL Subroutine call; push PC and move source to PC 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 RETI Return from interrupt; pop SR then pop PC 0 0 1 condition 10-bit signed offset Conditional jump; PC = PC + 2×offset 0 0 1 0 0 0 10-bit signed offset JNE/JNZ Jump if not equal/zero 0 0 1 0 0 1 10-bit signed offset JEQ/JZ Jump if equal/zero 0 0 1 0 1 0 10-bit signed offset JNC/JLO Jump if no carry/lower 0 0 1 0 1 1 10-bit signed offset JC/JHS Jump if carry/higher or same 0 0 1 1 0 0 10-bit signed offset JN Jump if negative 0 0 1 1 0 1 10-bit signed offset JGE Jump if greater or equal 0 0 1 1 1 0 10-bit signed offset JL Jump if less 0 0 1 1 1 1 10-bit signed offset JMP Jump (unconditionally) opcode source Ad B/W As destination Two-operand arithmetic 0 1 0 0 source Ad B/W As destination MOV Move source to destination 0 1 0 1 source Ad B/W As destination ADD Add source to destination 0 1 1 0 source Ad B/W As destination ADDC Add source and carry to destination 0 1 1 1 source Ad B/W As destination SUBC Subtract source from destination (with carry) 1 0 0 0 source Ad B/W As destination SUB Subtract source from destination 1 0 0 1 source Ad B/W As destination CMP Compare (pretend to subtract) source from destination 1 0 1 0 source Ad B/W As destination DADD Decimal add source to destination (with carry) 1 0 1 1 source Ad B/W As destination BIT Test bits of source AND destination 1 1 0 0 source Ad B/W As destination BIC Bit clear (dest &= ~src) 1 1 0 1 source Ad B/W As destination BIS Bit set (logical OR) 1 1 1 0 source Ad B/W As destination XOR Exclusive or source with destination 1 1 1 1 source Ad B/W As destination AND Logical AND source with destination (dest &= src) As !! Ad !! Register !! Syntax !! Description 00 0 n Rn Register direct. The operand is the contents of Rn. 01 1 n x(Rn) Indexed. The operand is in memory at address Rn+x. 10 — n @Rn Register indirect. The operand is in memory at the address held in Rn. 11 — n @Rn+ Indirect autoincrement. As above, then the register is incremented by 1 or 2. Addressing modes using R0 (PC) 01 1 0 (PC) ADDR Symbolic. Equivalent to x(PC). The operand is in memory at address PC+x. 11 — 0 (PC) #x Immediate. Equivalent to @PC+. The operand is the next word in the instruction stream. Addressing modes using R2 (SR) and R3 (CG), special-case decoding 01 1 2 (SR) &ADDR Absolute. The operand is in memory at address x. 10 — 2 (SR) #4 Constant. The operand is the constant 4. 11 — 2 (SR) #8 Constant. The operand is the constant 8. 00 — 3 (CG) #0 Constant. The operand is the constant 0. 01 — 3 (CG) #1 Constant. The operand is the constant 1. There is no index word. 10 — 3 (CG) #2 Constant. The operand is the constant 2. 11 — 3 (CG) #−1 Constant. The operand is the constant −1. Emulated !! Actual !! Description ADC.x dst ADDC.x #0,dst Add carry to destination BR dst MOV dst,PC Branch to destination CLR.x dst MOV.x #0,dst Clear destination CLRC BIC #1,SR Clear carry bit CLRN BIC #4,SR Clear negative bit CLRZ BIC #2,SR Clear zero bit DADC.x dst DADD.x #0,dst Decimal add carry to destination DEC.x dst SUB.x #1,dst Decrement DECD.x dst SUB.x #2,dst Double decrement DINT BIC #8,SR Disable interrupts EINT BIS #8,SR Enable interrupts INC.x dst ADD.x #1,dst Increment INCD.x dst ADD.x #2,dst Double increment INV.x dst XOR.x #−1,dst Invert NOP MOV #0,R3 No operation POP dst MOV @SP+,dst Pop from stack RET MOV @SP+,PC Return from subroutine RLA.x dst ADD.x dst,dst Rotate left arithmetic (shift left 1 bit) RLC.x dst ADDC.x dst,dst Rotate left through carry SBC.x dst SUBC.x #0,dst Subtract borrow (1−carry) from destination SETC BIS #1,SR Set carry bit SETN BIS #4,SR Set negative bit SETZ BIS #2,SR Set zero bit TST.x dst CMP.x #0,dst Test destination 15 !!width=15pt| 14 !!width=15pt| 13 !!width=15pt| 12 11 !!width=15pt| 10 !!width=15pt| 9 !!width=15pt| 8 7 !!width=15pt| 6 !!width=15pt| 5 !!width=15pt| 4 3 !!width=15pt| 2 !!width=15pt| 1 !!width=15pt| 0 !! Second word !! Instruction 0 0 0 0 source 0 0 opcode destination Extended memory-register moves 0 0 0 0 src 0 0 0 0 dst — MOVA @Rsrc,Rdst 0 0 0 0 src 0 0 0 1 dst — MOVA @Rsrc+,Rdst 0 0 0 0 addr[19:16] 0 0 1 0 dst addr[15:0] MOVA &abs20,Rdst 0 0 0 0 src 0 0 1 1 dst x[15:0] MOVA x(Rsrc),Rdst 0 0 0 0 n−1 op. 0 1 0 W/A destination Bit shifts (1–4 bit positions) 0 0 0 0 n−1 0 0 0 1 0 W/A dst — RRCM.x #n,Rdst (Rotate right through carry.) 0 0 0 0 n−1 0 1 0 1 0 W/A dst — RRAM.x #n,Rdst (Rotate right arithmetic, a.k.a. shift right signed.) 0 0 0 0 n−1 1 0 0 1 0 W/A dst — RLAM.x #n,Rdst (Rotate left arithmetic, a.k.a. shift left.) 0 0 0 0 n−1 1 1 0 1 0 W/A dst — RRUM.x #n,Rdst (Rotate right unsigned, a.k.a. shift right logical.) 0 0 0 0 source 0 1 1 op. destination Extended register-memory moves 0 0 0 0 src 0 1 1 0 addr[19:16] addr[15:0] MOVA Rsrc,&abs20 0 0 0 0 src 0 1 1 1 dst x[15:0] MOVA Rsrc,x(Rdst) 0 0 0 0 source 1 opcode destination Extended ALU operations 0 0 0 0 imm[19:16] 1 0 0 0 dst imm[15:0] MOVA #imm20,Rdst 0 0 0 0 imm[19:16] 1 0 0 1 dst imm[15:0] CMPA #imm20,Rdst 0 0 0 0 imm[19:16] 1 0 1 0 dst imm[15:0] ADDA #imm20,Rdst 0 0 0 0 imm[19:16] 1 0 1 1 dst imm[15:0] SUBA #imm20,Rdst 0 0 0 0 src 1 1 0 0 dst — MOVA Rsrc,Rdst 0 0 0 0 src 1 1 0 1 dst — CMPA Rsrc,Rdst 0 0 0 0 src 1 1 1 0 dst — ADDA Rsrc,Rdst 0 0 0 0 src 1 1 1 1 dst — SUBA Rsrc,Rdst 0 0 0 1 0 0 1 1 op. mode varies CALLA 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 — RETI (Same as MSP430) 0 0 0 1 0 0 1 1 0 1 As register CALLA source 0 0 0 1 0 0 1 1 1 0 0 0 abs[19:16] abs[15:0] CALLA &abs20 0 0 0 1 0 0 1 1 1 0 0 1 x[19:16] x[15:0] CALLA x(PC) 0 0 0 1 0 0 1 1 1 0 1 0 — — (reserved) 0 0 0 1 0 0 1 1 1 0 1 1 imm[19:16] imm[15:0] CALLA #imm20 0 0 0 1 0 0 1 1 1 1 — — (reserved) 0 0 0 1 0 1 dir W/A n−1 register Push/pop n registers ending with specified 0 0 0 1 0 1 0 W/A n−1 src — PUSHM.x #n,Rsrc &nbsp;Push Rsrc, R(src−1), ... R(src−n+1) 0 0 0 1 0 1 1 W/A n−1 dst−n+1 — POPM.x #n,Rdst &nbsp;Pop R(dst−n+1), R(dst−n+2), ... Rdst 15 !!width=15pt| 14 !!width=15pt| 13 !!width=15pt| 12 11 !!width=15pt| 10 !!width=15pt| 9 !!width=15pt| 8 7 !!width=15pt| 6 !!width=15pt| 5 !!width=15pt| 4 3 !!width=15pt| 2 !!width=15pt| 1 !!width=15pt| 0 !! Instruction 0 0 0 1 1 — A/L 0 0 — Extension word 0 0 0 1 1 src[19:16] A/L 0 0 dst[19:16] Memory operand extension 0 0 0 1 1 0 0 ZC 0 A/L 0 0 n−1 Register operand extension (immediate repeat count) 0 0 0 1 1 0 0 ZC 1 A/L 0 0 Rn Register operand extension (register repeat count) Name Manufacturer Interface Protocol(s) Status MSP-FET430PIF TI Parallel-Port JTAG MSP-FET430UIF TI USB-Interface JTAG, Spy-Bi-Wire MSP-FET TI USB-Interface JTAG, Spy-Bi-Wire MSP-430 LaunchPad TI USB-Interface Spy-Bi-Wire MSP-430 LaunchPad eZ-FET TI USB-Interface Spy-Bi-Wire eZ430-F2013 TI USB-Interface Spy-Bi-Wire eZ430-RF2500 TI USB-Interface Spy-Bi-Wire FETP SoftBaugh Parallel-Port JTAG USBP SoftBaugh USB-Interface JTAG, Spy-Bi-Wire discontinued MSP430-JTAG Olimex Parallel-Port JTAG MSP430-JTAG-ISO Olimex USB-Interface JTAG, Spy-Bi-Wire obsolete MSP430-JTAG-ISO-MK2 Olimex USB-Interface JTAG, Spy-Bi-Wire MSP430-JTAG-Tiny Olimex USB-Interface JTAG, Spy-Bi-Wire not found MSP430-JTAG-TINY-V2 Olimex USB-Interface JTAG?, Spy-Bi-Wire MSP430-JTAG-RF Olimex USB-Interface JTAG, Spy-Bi-Wire FlashPro-CC Elprotronic USB-Interface JTAG, Spy-Bi-Wire, BSL VisSim/ECD Visual Solutions USB-Interface JTAG, Spy-Bi-Wire LA-3713 Lauterbach USB-Interface / Ethernet JTAG, Spy-bi-Wire Processor special function registers (interrupt control registers) 8-bit peripherals. These must be accessed using 8-bit loads and stores. 16-bit peripherals. These must be accessed using 16-bit loads and stores. Up to 2048 bytes of RAM. 1024 bytes of bootstrap loader ROM (flash parts only). 256 bytes of data flash ROM (flash parts only). Extended RAM on models with more than 2048 bytes of RAM.  (0x1100–0x18FF is a copy of 0x0200–0x09FF) Up to 60 kilobytes of program ROM. Smaller ROMs start at higher addresses. The last 16 or 32 bytes are interrupt vectors. MSP430: Standard prefix. F: Indicates a memory type or specialized application. "F" indicating flash memory is by far the most popular. Other options for memory type include "C" for masked ROM, "FR" for FRAM, "G" for Flash Value Line, and "L" as in the MSP430L09x series, which indicates a RAM-only part; it must remain continuously powered to retain its programming. A second letter (except for "FR") indicates a specialized application for the part. For example, "G" is an optional specialization letter indicating hardware support for a specialized use. "E" indicates special electricity meter functions, "G" devices are designed for medical instrumentation, and "W" devices include a special "scan interface" designed for flow meters. An exception is the MSP430FG2xx devices, which are considered a separate generation. 2: The generation of device. There can be significant changes to core peripherals (clock generators, UARTs, etc.) in different generations. These are not in chronological order, but rather higher values roughly indicate greater size, complexity and cost. For example, generations 3 and 4 include LCD controllers which the others do not. 6: The model within the generation. This indicates the mixture of on-board peripheral devices and number of pins. 18: One or two digits indicating the amount of memory on the device. The numbering is (mostly) consistent throughout the MSP430 series. Not all suffixes are valid with all models; most models are available in 3–6 memory sizes, chosen to match the other capabilities of the device. Larger numbers indicate increasing amounts of memory, but sometimes one type of memory (RAM or ROM) is sacrificed to fit more of the other. An optional suffix digit indicating a variant device, adding or deleting some analog peripherals. For example, a "1" suffix may indicate the addition of a comparator or deletion of an ADC.  If the memory size is "1", this suffix can be confused with part of the memory size, but no single model is available in both "1" and "10" (or greater) memory sizes. An optional "A" suffix indicating an upward-compatible revised version.  The MSP430F11x1A has an additional 256 bytes of data flash not present in the plain 'F11x1. T: Indicates a temperature range of −40&nbsp;°C to +105&nbsp;°C. ZQW: Indicates the package the part is kept in.  "ZQW" is a TI-specific name for a ball grid array. T: Indicates that the parts are shipped in small reel (7-inch) packaging. -EP: Indicates an additional feature. "-Q1" specifies that the part is automotive qualified. "-EP" and "-HT" indicate extended temperature products. Enhanced products, "-EP", have a temperature range from -40&nbsp;°C to 125&nbsp;°C, and extreme temperature parts, "-HT", have a temperature range from -56&nbsp;°C to 150&nbsp;°C. A limited number of 20-bit instructions for common operations, and A general prefix-word mechanism that can extend any instruction to 20 bits. TI MSP430 Homepage TI E2E MSP430 Community forum MSP430 Community sponsored by Texas Instruments MSP430 Yahoo!group MSP430.info MSP430 English-Japanese forum 43oh.com &ndash; MSP430 News, Projects and Forums TinyOS-MSP430 TinyOS port VisSim MSP430 Model-Based Embedded Development System WSim - a software-driven emulator for full platform estimations and debug MSPSim - a Java based MSP430 emulator/simulator MSP430Static - a reverse engineering tool in Perl GoodFET - an open MSP430 JTAG debugger in C and Python mspdebug - an opensource MSP430 JTAG debugger Trace32 MSP430 SIM - Download area with MSP430 Instruction Set Simulator free for evaluation ERIKA Enterprise - a free of charge, open source RTOS implementation of the ISO 17356 API (derived from the OSEK/VDX API) Energia is based on Wiring and Arduino and uses the Processing IDE. The hardware platform is based upon TI MSP430 Launchpad

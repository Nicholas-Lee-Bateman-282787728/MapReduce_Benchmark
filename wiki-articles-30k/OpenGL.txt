   Open Graphics Library (OpenGL) https://www.opengl.org/wiki/Main_Page    http://faculty.ycp.edu/~dbabcock/PastCourses/cs370/labs/index.html  is a cross-language, cross-platform application programming interface (API) for rendering 2D and 3D vector graphics. The API is typically used to interact with a graphics processing unit (GPU), to achieve hardware-accelerated rendering. Silicon Graphics Inc., (SGI) started developing OpenGL in 1991 and released it in January 1992; applications use it extensively in the fields of computer-aided design (CAD), virtual reality, scientific visualization, information visualization, flight simulation, and video games. OpenGL is managed by the non-profit technology consortium Khronos Group.  The OpenGL specification describes an abstract API for drawing 2D and 3D graphics. Although it is possible for the API to be implemented entirely in software, it is designed to be implemented mostly or entirely in hardware. The API is defined as a set of functions which may be called by the client program, alongside a set of named integer constants (for example, the constant GL_TEXTURE_2D, which corresponds to the decimal number 3553). Although the function definitions are superficially similar to those of the programming language C, they are language-independent. As such, OpenGL has many language bindings, some of the most noteworthy being the JavaScript binding WebGL (API, based on OpenGL ES 2.0, for 3D rendering from within a web browser); the C bindings WGL, GLX and CGL; the C binding provided by iOS; and the Java and C bindings provided by Android. In addition to being language-independent, OpenGL is also cross-platform. The specification says nothing on the subject of obtaining, and managing, an OpenGL context, leaving this as a detail of the underlying windowing system. For the same reason, OpenGL is purely concerned with rendering, providing no APIs related to input, audio, or windowing. OpenGL is an evolving API. New versions of the OpenGL specifications are regularly released by the Khronos Group, each of which extends the API to support various new features. The details of each version are decided by consensus between the Group's members, including graphics card manufacturers, operating system designers, and general technology companies such as Mozilla and Google. In addition to the features required by the core API, graphics processing unit (GPU) vendors may provide additional functionality in the form of extensions. Extensions may introduce new functions and new constants, and may relax or remove restrictions on existing OpenGL functions. Vendors can use extensions to expose custom APIs without needing support from other vendors or the Khronos Group as a whole, which greatly increases the flexibility of OpenGL. All extensions are collected in, and defined by, the OpenGL Registry. Each extension is associated with a short identifier, based on the name of the company which developed it. For example, Nvidia's identifier is NV, which is part of the extension name GL_NV_half_float, the constant GL_HALF_FLOAT_NV, and the function glVertex2hNV().http://www.opengl.org/registry/specs/NV/half_float.txt If multiple vendors agree to implement the same functionality using the same API, a shared extension may be released, using the identifier EXT. In such cases, it could also happen that the Khronos Group's Architecture Review Board gives the extension their explicit approval, in which case the identifier ARB is used. The features introduced by each new version of OpenGL are typically formed from the combined features of several widely implemented extensions, especially extensions of type ARB or EXT. OpenGL's popularity is partially due to the quality of its official documentation. The OpenGL Architecture Review Board released a series of manuals along with the specification which have been updated to track changes in the API. These are almost universally known by the colors of their covers: Historic books (pre-OpenGL 2.0): The earliest versions of OpenGL were released with a companion library called the OpenGL Utility Library (GLU). It provided simple, useful features which were unlikely to be supported in contemporary hardware, such as tessellating, and generating mipmaps and primitive shapes. The GLU specification was last updated in 1998, and the latest version depends on features which were deprecated with the release of OpenGL 3.1 in 2009. Given that creating an OpenGL context is quite a complex process, and given that it varies between operating systems, automatic OpenGL context creation has become a common feature of several game-development and user-interface libraries, including SDL, Allegro, SFML, FLTK, and Qt. A few libraries have been designed solely to produce an OpenGL-capable window. The first such library was OpenGL Utility Toolkit (GLUT), later superseded by freeglut. GLFW is a newer alternative. *GLFW — A cross-platform windowing and keyboard-mouse-joystick handler; is more game-oriented *freeglut — A cross-platform windowing and keyboard-mouse handler; its API is a superset of the GLUT API, and it is more stable and up to date than GLUT *OpenGL Utility Toolkit (GLUT)— An old windowing handler, no longer maintained *Allegro 5 — A cross-platform multimedia library with a C API focused on game development *Simple DirectMedia Layer (SDL) — A cross-platform multimedia library with a C API *SFML — A cross-platform multimedia library with a C++ API *FLTK — A small cross-platform C++ widget library *Qt — A cross-platform C++ widget toolkit. It provides many OpenGL helper objects, which even abstract away the difference between desktop GL and OpenGL ES *wxWidgets — A cross-platform C++ widget toolkit Given the high workload involved in identifying and loading OpenGL extensions, a few libraries have been designed which load all available extensions and functions automatically. Examples include GLEE, GLEW and glbinding. Extensions are also loaded automatically by most language bindings, such as JOGL and PyOpenGL. Mesa 3D is an open source implementation of OpenGL. It can do pure software rendering, and it may also use hardware acceleration on the Linux platform by taking advantage of the Direct Rendering Infrastructure. As of version 10.0, it implements version 3.3 of the OpenGL standard. In the 1980s, developing software that could function with a wide range of graphics hardware was a real challenge. Software developers wrote custom interfaces and drivers for each piece of hardware. This was expensive and resulted in multiplication of effort. By the early 1990s, Silicon Graphics (SGI) was a leader in 3D graphics for workstations. Their IRIS GL API was considered state-of-the-art and became the de facto industry standard, overshadowing the open standards-based PHIGS. This was because IRIS GL was considered easier to use, and because it supported immediate mode rendering. By contrast, PHIGS was considered difficult to use and outdated in functionality. SGI's competitors (including Sun Microsystems, Hewlett-Packard and IBM) were also able to bring to market 3D hardware, supported by extensions made to the PHIGS standard. This in turn caused SGI market share to weaken as more 3D graphics hardware suppliers entered the market. In an effort to influence the market, SGI decided to turn the IrisGL API into an open standard – OpenGL. However, SGI had many software customers for whom the change from IrisGL to OpenGL would demand significant investment. Moreover, IrisGL had API functions that were irrelevant to 3D graphics. For example, it included a windowing, keyboard and mouse API, in part because it was developed before the X Window System and Sun's NeWS. And, IrisGL libraries were unsuitable for opening due to licensing and patent issues. These factors required SGI to continue to support the advanced and proprietary Iris Inventor and Iris Performer programming APIs while market support for OpenGL matured. One of the restrictions of IrisGL was that it only provided access to features supported by the underlying hardware. If the graphics hardware did not support a feature, then the application could not use it. OpenGL overcame this problem by providing support in software for features unsupported by hardware, allowing applications to use advanced graphics on relatively low-powered systems. OpenGL standardized access to hardware, pushed the development responsibility of hardware interface programs (sometimes called device drivers) to hardware manufacturers, and delegated windowing functions to the underlying operating system. With so many different kinds of graphics hardware, getting them all to speak the same language in this way had a remarkable impact by giving software developers a higher level platform for 3D-software development. In 1992, SGI led the creation of the OpenGL Architecture Review Board (OpenGL ARB), the group of companies that would maintain and expand the OpenGL specification in the future. In 1994, SGI played with the idea of releasing something called "OpenGL++" which included elements such as a scene-graph API (presumably based on their Performer technology). The specification was circulated among a few interested parties – but never turned into a product. Microsoft released Direct3D in 1995, which eventually became the main competitor of OpenGL. On December 17, 1997, Microsoft and SGI initiated the Fahrenheit project, which was a joint effort with the goal of unifying the OpenGL and Direct3D interfaces (and adding a scene-graph API too). In 1998, Hewlett-Packard joined the project. It initially showed some promise of bringing order to the world of interactive 3D computer graphics APIs, but on account of financial constraints at SGI, strategic reasons at Microsoft, and general lack of industry support, it was abandoned in 1999. In July 2006 the OpenGL Architecture Review Board voted to transfer control of the OpenGL API standard to the Khronos Group.OpenGL ARB to pass control of OpenGL specification to Khronos Group, Khronos press releaseOpenGL ARB to Pass Control of OpenGL Specification to Khronos Group, AccessMyLibrary Archive The first version of OpenGL, version 1.0, was released in January 1992 by Mark Segal and Kurt Akeley. Since then, OpenGL has occasionally been extended by releasing a new version of the specification. Such releases define a baseline set of features which all conforming graphics cards must support, and against which new extensions can more easily be written. Each new version of OpenGL tends to incorporate several extensions which have widespread support among graphics-card vendors, although the details of those extensions may be changed. Release date: March 4, 1997 Release date: March 16, 1998 One notable feature of OpenGL 1.2 was the introduction of the imaging subset. This is a set of features which are very useful to image-processing applications, but which have limited usefulness elsewhere. Implementation of this subset has always been optional; support is indicated by advertising the extension string ARB_imaging. Release date: October 14, 1998 OpenGL 1.2.1 was a minor release, appearing only seven months after the release of version 1.2. It introduced the concept of ARB extensions, and defined the extension ARB_multitexture, without yet incorporating it into the OpenGL core specification. Release date: August 14, 2001 Release date: July 24, 2002 Release date: July 29, 2003 Alongside the release of OpenGL 1.5, the ARB released the OpenGL Shading Language specification, and the extensions ARB_shader_objects, ARB_vertex_shader, and ARB_fragment_shader. However, these would not be incorporated into the core specification until the next release. Release date: September 7, 2004 OpenGL 2.0 was originally conceived by 3Dlabs to address concerns that OpenGL was stagnating and lacked a strong direction. 3Dlabs proposed a number of major additions to the standard. Most of these were, at the time, rejected by the ARB or otherwise never came to fruition in the form that 3Dlabs proposed. However, their proposal for a C-style shading language was eventually completed, resulting in the current formulation of the OpenGL Shading Language (GLSL or GLslang). Like the assembly-like shading languages it was replacing, it allowed replacing the fixed-function vertex and fragment pipe with shaders, though this time written in a C-like high-level language. The design of GLSL was notable for making relatively few concessions to the limits of the hardware then available. This hearkened back to the earlier tradition of OpenGL setting an ambitious, forward-looking target for 3D accelerators rather than merely tracking the state of currently available hardware. The final OpenGL 2.0 specificationhttp://www.opengl.org/documentation/specs/version2.0/glspec20.pdf includes support for GLSL. Release date: July 2, 2006 OpenGL 2.1 required implementations to support version 1.20 of the OpenGL Shading Language. Before the release of OpenGL 3.0, the new revision had the codename Longs Peak. At the time of its original announcement, Longs Peak was presented as the first major API revision in OpenGL's lifetime. It consisted of an overhaul to the way that OpenGL works, calling for fundamental changes to the API. The draft introduced a change to object management. The GL 2.1 object model was built upon the state-based design of OpenGL. That is, to modify an object or to use it, one needs to bind the object to the state system, then make modifications to the state or perform function calls that use the bound object. Because of OpenGL's use of a state system, objects must be mutable. That is, the basic structure of an object can change at any time, even if the rendering pipeline is asynchronously using that object. A texture object can be redefined from 2D to 3D. This requires any OpenGL implementations to add a degree of complexity to internal object management. Under the Longs Peak API, object creation would become atomic, using templates to define the properties of an object which would be created with one function call. The object could then be used immediately across multiple threads. Objects would also be immutable; however, they could have their contents changed and updated. For example, a texture could change its image, but its size and format could not be changed. To support backwards compatibility, the old state based API would still be available, but no new functionality would be exposed via the old API in later versions of OpenGL. This would have allowed legacy code bases, such as the majority of CAD products, to continue to run while other software could be written against or ported to the new API. Longs Peak was initially due to be finalized in September 2007 under the name OpenGL 3.0, but the Khronos Group announced on October 30 that it had run into several issues that it wished to address before releasing the specification. As a result, the spec was delayed, and the Khronos Group went into a media blackout until the release of the final OpenGL 3.0 spec. The final specification proved far less revolutionary than the Longs Peak proposal. Instead of removing all immediate mode and fixed functionality (non-shader mode), the spec included them as deprecated features. The proposed object model was not included, and no plans have been announced to include it in any future revisions. As a result, the API remained largely the same with a few existing extensions being promoted to core functionality. Among some developer groups this decision caused something of an uproar, with many developers professing that they would switch to DirectX in protest. Most complaints revolved around the lack of communication by Khronos to the development community and multiple features being discarded that were viewed favorably by many. Other frustrations included the requirement of DirectX 10 level hardware to use OpenGL 3.0 and the absence of geometry shaders and instanced rendering as core features. Other sources reported that the community reaction was not quite as severe as originally presented, with many vendors showing support for the update. Release date: August 11, 2008 OpenGL 3.0 introduced a deprecation mechanism to simplify future revisions of the API. Certain features, marked as deprecated, could be completely disabled by requesting a forward-compatible context from the windowing system. OpenGL 3.0 features could still be accessed alongside these deprecated features, however, by requesting a full context. Deprecated features include: Release date: March 24, 2009 OpenGL 3.1 fully removed all of the features which were deprecated in version 3.0, with the exception of wide lines. From this version onwards, it's not possible to access new features using a full context, or to access deprecated features using a forward-compatible context. An exception to the former rule is made if the implementation supports the ARB_compatibility extension, but this is not guaranteed. Release date: August 3, 2009 OpenGL 3.2 further built on the deprecation mechanisms introduced by OpenGL 3.0, by dividing the specification into a core profile and compatibility profile. Compatibility contexts include the previously-removed fixed-function APIs, equivalent to the ARB_compatibility extension released alongside OpenGL 3.1, while core contexts do not. OpenGL 3.2 also included an upgrade to GLSL version 1.50. Release date: March 11, 2010 OpenGL 3.3 was released alongside version 4.0. It was designed to target hardware able to support Direct3D 10. Release date: March 11, 2010 OpenGL 4.0 was released alongside version 3.3. It was designed for hardware able to support Direct3D 11. As in OpenGL 3.0, this version of OpenGL contains a high number of fairly inconsequential extensions, designed to thoroughly expose the abilities of Direct3D 11-class hardware. Only the most influential extensions are listed below. Hardware support: Nvidia GeForce 400 Series and newer, ATI Radeon HD 5000 Series and newer, Intel HD Graphics in Intel Ivy Bridge processors and newer. Release date: July 26, 2010 Hardware support: Nvidia GeForce 400 Series and newer ATI Radeon HD 5000 Series and Intel HD Graphics in Intel Ivy Bridge processors and newer. Release date: August 8, 2011 Hardware support: Nvidia GeForce 400 Series and newer ATI Radeon HD 5000 Series and Intel HD Graphics in Intel Haswell processors and newer. Release date: August 6, 2012 Hardware support: Nvidia GeForce 400 Series and newer, ATI Radeon HD 5000 Series and newer, Intel HD Graphics in Intel Haswell processors and newer. Release date: July 22, 2013 Hardware support: Nvidia GeForce 400 series and newer, AMD Radeon HD 5000 Series and newer, Intel HD Graphics in Intel Skylake processors and newer, Tegra K1. Release date: August 11, 2014 Hardware support: Nvidia GeForce 400 series and newer, AMD Radeon HD 7000 Series and newer, Tegra K1, and Tegra X1.  Vulkan, formerly named the "Next Generation OpenGL Initiative" (glNext), is a grounds-up redesign effort to unify OpenGL and OpenGL ES into one common API that will not be backwards compatible with existing OpenGL versions. AMD offered its Mantle API without any conditions as the foundation of Vulkan. A 2015 Game Developers Conference (GDC) conference session by Valve Corporation, with participation from Electronic Arts, Epic Games and Unity Technologies, unveiled Vulkan. On 3 March 2015, Valve announced Source 2 which will be compatible with Vulkan.   Extension Details EXT_vertex_array Multiple vertices may be passed to the GL with one function call EXT_polygon_offset Depth values may be offset on a per-primitive basis EXT_blend_logic_op Fragment colors may be blended into the framebuffer using bitwise operations EXT_texture Various texturing improvements, including proxy textures and sized internal formats EXT_copy_textureEXT_subtexture Various methods to alter texture images, including image copying and sub-image replacement EXT_texture_object Texture state may be stored in a GL object, for greater efficiency Extension Details EXT_texture3D Three-dimensional texturing EXT_bgra Pixel data may be specified in BGR or BGRA order, to match the pixel format of Windows bitmaps EXT_packed_pixels Pixel data may be packed into a larger primitive type; for example, all four components of an RGBA pixel may be specified as one 32-bit integer EXT_rescale_normal Normals may be automatically rescaled by the GL, which in some cases removes the need for a costly normalization EXT_separate_specular_color The GL's lighting abilities are extended to support texture-independent specular highlighting SGIS_texture_edge_clamp A new texture-coordinate clamping mode which, unlike GL_CLAMP, will never sample from the texture's border SGIS_texture_lod Gives greater control over the level-of-detail calculation used to select a texture's mipmap EXT_draw_range_elements The DrawRangeElements function; a slightly faster alternative to DrawElements Extension Details ARB_texture_compression A standard framework on which compressed texture formats may be supported, without needing other compression support ARB_texture_cube_map Cube-mapped texturing. ARB_multisample A standard framework upon which multisample anti-aliasing may be supported, without needing other MSAA support ARB_multitexture Color values from several textures at once may be blended onto one fragment ARB_texture_env_addARB_texture_env_combineARB_texture_env_dot3 Several new "texture environment functions": mechanisms for blending texture colors onto fragment colors ARB_texture_border_clamp A new texture-coordinate clamping mode which forces out-of-bounds texture coordinates to sample from a texture's border ARB_transpose_matrix Transformation matrices may be specified in either order: row-major or column-major Extension Details SGIS_generate_mipmap Texture mipmaps may be generated automatically by the GL NV_blend_square RGB and Alpha values may be squared during alpha-blending EXT_blend_colorEXT_blend_minmaxEXT_blend_subtract Various ways to customize the blend equation, promoted from the optional imaging subset (introduced in version 1.2) to the core specification ARB_depth_textureARB_shadow Textures which store depth values, rather than color values; such textures are useful for shadow-casting and displacement maps EXT_fog_coord A way to customize the fog intensity per vertex EXT_multi_draw_arrays A set of APIs which emulate multiple calls to DrawArrays or DrawElements, in one function call; in some cases, this may be more efficient ARB_point_parameters Greater control over rasterizing point primitives EXT_secondary_color The "secondary color" mechanism defined by EXT_separate_specular_color may be used in all circumstances, even with lighting disabled EXT_blend_func_separate Separate blending functions may be specified for the RGB and Alpha components of the blended pixels EXT_stencil_wrap A stencil mode which causes stencil values to increment with wrapping ARB_texture_env_crossbar Texture environment functions may access all other texture stages, rather than being restricted to the texture bound to their own texture unit EXT_texture_lod_bias A means to bias computing mipmap weights to add blur or sharpening effects to texture filtering ARB_texture_mirrored_repeat A new texture-coording wrapping mode which causes the texture image to be horizontally or vertically mirrored ARB_window_pos The WindowPos API, an alternative to RasterPos which sets the raster-output position in screen space rather than world space Extension Details ARB_vertex_buffer_object A new type of GL object, the "buffer", which stores various types of data (especially vertex data) in fast video memory ARB_occlusion_query The programmer may query whether or not a primitive was occluded during rendering EXT_shadow_funcs The abilities of the ARB_shadow extension are slightly extended Extension Details ARB_shading_language_100 (heavily modified)ARB_shader_objects (heavily modified)ARB_vertex_shader (heavily modified)ARB_fragment_shader (heavily modified) The high-level OpenGL Shading Language, which provides direct access to programmable vertex and fragment processors ARB_draw_buffers Fragment shaders may output different colors to multiple render-targets in one pass; support for multiple render-targets would not be guaranteed until OpenGL 3.0 ARB_texture_non_power_of_two Texture images may have non-power-of-two dimensions ARB_point_sprite Points may be rendered as small, screen-oriented texture quads; useful when developing particle systems EXT_blend_equation_separate Separate blending equations may be specified for the RGB and Alpha components of the blended pixels, similar to EXT_blend_func_separate ATI_separate_stencilEXT_stencil_two_side Separate stencil algorithms may be used when rendering the front and back faces of primitives Extension Details ARB_pixel_buffer_object Buffer objects may be used for asynchronous transfers of image data. EXT_texture_sRGB Texture pixel values may be specified in the gamma-corrected sRGB color space Extension Details EXT_gpu_shader4 API functions required by version 1.30 of the OpenGL Shading Language ARB_map_buffer_range Mapping of buffer subranges into client space and flushing modified data ARB_color_buffer_floatNV_depth_buffer_floatARB_texture_floatEXT_packed_floatEXT_texture_shared_exponent Floating-point color and depth internal formats for textures and renderbuffers ARB_half_float_pixelNV_half_float Half-float (16-bit) vertex array and pixel data formats EXT_framebuffer_object A new type of GL object, the "framebuffer"; these enable rendering offscreen and to textures EXT_framebuffer_sRGB Use of the sRGB gamma-corrected image data in framebuffers EXT_framebuffer_blitEXT_framebuffer_multisample Functions to perform a fast bit blit between render-targets ARB_texture_floatEXT_texture_integer Support for floating-point and non-normalized integer texture storage EXT_packed_depth_stencil Packed depth/stencil internal formats for combined depth+stencil textures and renderbuffers EXT_draw_buffers2 Per-color-attachment blend enables and color writemasks GL_EXT_texture_array One- and two-dimensional layered texture targets EXT_texture_compression_rgtc The RGTC texture-compression format, for compressing one or two-channels of image data EXT_transform_feedback The results of vertex processing can be captured into buffers, rather than (or in addition to) being passed to the rest of the pipeline ARB_vertex_array_object A new type of GL object, the "vertex array object", which stores a set of bindings to vertex arrays; this allows such arrays to be rebound with one function call rather than several calls to EnableVertexAttribArray, VertexAttribPointer, etc. NV_conditional_render Conditional rendering, based on the results of an occlusion query Extension Details ARB_draw_instanced Instanced rendering: the ability to quickly render the same geometry data multiple times, with the vertex shader being given information specifying the instance it is operating on EXT_copy_buffer (See: ARB_copy_buffer) A mechanism to copy data directly between buffer objects ARB_texture_buffer_object Buffer textures: one-dimensional textures, where the pixel data store comes from a buffer object ARB_texture_rectangle Rectangular textures ARB_uniform_buffer_object The ability to store a set of shader parameters in a buffer object NV_primitive_restart The ability to specify that an index restarts a primitive, so that objects can be called with fewer calls to DrawElements Extension Details ARB_geometry_shader4 (heavily modified) Geometry shaders ARB_sync A set of GL objects representing synchronization primitives, which allow the client to detect when a specific set of tasks has completed ARB_vertex_array_bgra Per-vertex color data may be specified in BGRA order, matching the convention used by Direct3D ARB_draw_elements_base_vertex The DrawElements API is extended to automatically add a numerical offset (the base vertex) to each array index ARB_seamless_cube_map Forces blending between different faces when sampling from a cube map ARB_texture_multisample A new type of texture, which can be used as a multisampled render target ARB_fragment_coord_conventions Allow fragment shaders to read fragment coordinate locations in the same conventions as Direct3D ARB_provoking_vertex The developer may configure which vertex determines the properties for flat-shaded vertex components ARB_depth_clamp The developer may configure whether or not triangles are clipped against the near/far Z range Extension Details ARB_shader_bit_encoding Adds shading language functions to perform conversions from/to floating-point and integers; this extension only affects the shading language ARB_blend_func_extended Fragment shaders can output multiple colors that can be used in one Alpha blending operation ARB_explicit_attrib_location Shader inputs and outputs may be assigned resource locations in the shader ARB_occlusion_query2 The occlusion-query system is extended to support querying whether entire objects were occluded, rather than querying the exact number of occluded pixels; in some cases, this may be more efficient ARB_sampler_objects A new GL object which wraps some texture object state, such as interpolation and clamping; allows one texture to be simultaneously accessed in multiple ways ARB_texture_swizzle Allows configuring the order in which components in a texture are presented to a shader when it samples them ARB_timer_query Functions to accurately measure the time taken by an operation; information useful for profiling purposes ARB_instanced_arrays When performing instanced rendering, instances may be configured using per-instance vertex attributes rather than using a vertex shader parameter to access an array ARB_texture_rgb10_a2uiARB_vertex_type_2_10_10_10_rev Image and vertex data may be specified by packing three 10-bit normalized integer values into one 32-bit integer Extension Details ARB_tessellation_shader Two new shader stages (tessellation-control and tessellation-evaluation) to support efficient geometry generation on GPUs ARB_shader_subroutine The ability to call different subroutines within a shader dynamically, without recompiling the source ARB_sample_shading Allows requesting that a fragment program is evaluated for each sample within a fragment, which increases the fidelity of multisampled anti-aliasing ARB_draw_buffers_blend The ability to set individual blend equations and blend functions for each color output ARB_draw_indirect A mechanism to supply the arguments to certain Draw functions from buffer-object memory, combined with transform feedback or OpenCL, this allows GPUs to render without synchronising with CPUs ARB_transform_feedback2ARB_transform_feedback3 A set of improvements to EXT_transform_feedback Extension Details ARB_ES2_compatibility Full API compatibility with OpenGL ES 2.0 ARB_get_program_binary The ability to retrieve the content of program objects in a binary, vendor-specific format; eliminates the need to recompile shaders whenever the program is run, but the resulting binaries are not transferable between GPUs ARB_separate_shader_objects Program objects may be separately associated with each of the five shading stages, instead of using separate shader stages linked into a monolithic program object; the extension also introduces glProgramUniform, which accepts a program object as parameter, thus enabling direct access to program's uniforms ARB_viewport_array The ability to define multiple viewports and scissor rectangles, to be used when generating several scenes at once from a geometry shader ARB_vertex_attrib_64bit Vertex attributes can be double-precision values ARB_shader_precision The ability to specify the precision of certain operations in the shading language OpenGL Programming Guide, 8th Edition. ISBN 0-321-77303-9 A tutorial and reference book. OpenGL Shading Language, 3rd edition. ISBN 0-321-63763-1 A tutorial and reference book for GLSL. OpenGL Programming for the X Window System. ISBN 978-0-201-48359-8 A book about X11 interfacing and OpenGL Utility Toolkit (GLUT). OpenGL Reference manual, 4th edition. ISBN 0-321-17383-X Essentially a hard-copy printout of the Unix manual (man) pages for OpenGL. Includes a poster-sized fold-out diagram showing the structure of an idealised OpenGL implementation. OpenGL Programming for Windows 95 and Windows NT. ISBN 0-201-40709-4 A book about interfacing OpenGL with Microsoft Windows. These toolkits are designed to create and manage OpenGL windows, and manage input, but little beyond that. Several "multimedia libraries" can create OpenGL windows, in addition to input, sound and other tasks useful for game-like applications Widget toolkits All fixed-function vertex and fragment processing Direct-mode rendering, using glBegin and glEnd Display lists Indexed-color rendering targets OpenGL Shading Language versions 1.10 and 1.20 Support for shaders with atomic counters and load-store-atomic read-modify-write operations to one level of a texture Drawing multiple instances of data captured from GPU vertex processing (including tessellation), to enable complex objects to be efficiently repositioned and replicated Support for modifying an arbitrary subset of a compressed texture, without having to re-download the whole texture to the GPU for significant performance improvements Compute shaders leveraging GPU parallelism within the context of the graphics pipeline Shader storage buffer objects, allowing shaders to read and write buffer objects like image load/store from 4.2, but through the language rather than function calls. Image format parameter queries ETC2/EAC texture compression as a standard feature Full compatibility with OpenGL ES 3.0 APIs Debug abilities to receive debugging messages during application development Texture views to interpret textures in different ways without data replication Increased memory security and multi-application robustness Enforced buffer object usage controls Asynchronous queries into buffer objects Expression of more layout controls of interface variables in shaders Efficient binding of multiple objects simultaneously Direct State Access (DSA) – object accessors enable state to be queried and modified without binding objects to contexts, for increased application and middleware efficiency and flexibility. Flush Control – applications can control flushing of pending commands before context switching – enabling high-performance multithreaded applications; Robustness – providing a secure platform for applications such as WebGL browsers, including preventing a GPU reset affecting any other running applications; OpenGL ES 3.1 API and shader compatibility – to enable the easy development and execution of the latest OpenGL ES applications on desktop systems. ARB assembly language – OpenGL's legacy low-level shading language Comparison of OpenGL and Direct3D Glide API – a graphics API once used on 3dfx Voodoo cards List of OpenGL programs OpenAL – Cross-platform audio library, designed to resemble OpenGL OpenGL ES – OpenGL for embedded systems OpenSL ES – API for audio on embedded systems, developed by the Khronos Group OpenVG – API for accelerated 2D graphics, developed by the Khronos Group RenderMan Interface Specification (RISpec) – Pixar's open API for photorealistic off-line rendering VOGL – a debugger for OpenGL Vulkan – low-level, cross-platform 2D and 3D graphics API, the "next generation OpenGL initiative" OpenGL.org's Wiki with more information on OpenGL Language bindings SGI's OpenGL website Khronos Group, Inc. Edward Angel and Dave Shreiner (2013) SIGGRAPH University: "An Introduction to OpenGL Programming"—free course Tutorial for modern OpenGL (3.3+) OpenGL 3.x/4.x examples OpenGL (version 3 and higher) examples

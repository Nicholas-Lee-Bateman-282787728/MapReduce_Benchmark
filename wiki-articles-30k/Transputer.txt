    The transputer  was a pioneering microprocessor architecture of the 1980s, featuring integrated memory and serial communication links, intended for parallel computing. It was designed and produced by Inmos, a semiconductor company based in Bristol, United Kingdom.Allen Kent, James G. Williams (eds.) (1998) "Encyclopedia of Computer Science and Technology", ISBN 0-8247-2292-2, "The Transputer Family of Products", by Hamid R. Arabnia For some time in the late 1980s, many considered the transputer to be the next great design for the future of computing. While Inmos and the transputer did not ultimately live up to this expectation, the transputer architecture was highly influential in provoking new ideas in computer architecture, several of which have re-emerged in different forms in modern systems. In the early 1980s, conventional CPUs appeared to reach a performance limit. Up to that time, manufacturing difficulties limited the amount of circuitry designers could place on a chip. Continued improvements in the fabrication process, however, removed this restriction. Soon the problem became that the chips could hold more circuitry than the designers knew how to use. Traditional CISC designs were reaching a performance plateau, and it wasn't clear it could be overcome. It seemed that the only way forward was to increase the use of parallelism, the use of several CPUs that would work together to solve several tasks at the same time. This depended on the machines in question being able to run several tasks at once, a process known as multitasking. This had generally been too difficult for previous CPU designs to handle, but more recent designs were able to accomplish it effectively. It was clear that in the future this would be a feature of all operating systems. A side effect of most multitasking design is that it often also allows the processes to be run on physically different CPUs, in which case it is known as multiprocessing. A low-cost CPU built with multiprocessing in mind could allow the speed of a machine to be increased by adding more CPUs, potentially far more cheaply than by using a single faster CPU design. The first transputer designs were due to David May and Robert Milne. In 1990, May received an Honorary DSc from University of Southampton, followed in 1991 by his election as a Fellow of The Royal Society and the award of the Patterson Medal of the Institute of Physics in 1992. Tony Fuge, a leading engineer at Inmos at the time, was awarded the Prince Philip Designers Prize in 1987 for his work on the T414 transputer. The transputer (the name deriving from transistor and computer) was the first general purpose microprocessor designed specifically to be used in parallel computing systems.  The goal was to produce a family of chips ranging in power and cost that could be wired together to form a complete parallel computer. The name was selected to indicate the role the individual transputers would play: numbers of them would be used as basic building blocks, just as transistors had earlier. Originally the plan was to make the transputer cost only a few dollars per unit. Inmos saw them being used for practically everything, from operating as the main CPU for a computer to acting as a channel controller for disk drives in the same machine. Spare cycles on any of these transputers could be used for other tasks, greatly increasing the overall performance of the machines. Even a single transputer would have all the circuitry needed to work by itself, a feature more commonly associated with microcontrollers. The intention was to allow transputers to be connected together as easily as possible, without the requirement for a complex bus (or motherboard). Power and a simple clock signal had to be supplied, but little else: RAM, a RAM controller, bus support and even an RTOS were all built in. The original transputer used a very simple and rather unique architecture to achieve a high performance in a small area. It used microcode as the principal method of controlling the data path but unlike other designs of the time, many instructions took only a single cycle to execute. Instruction opcodes were used as the entry points to the microcode ROM and the outputs from the ROM were fed directly to the data path. For multi-cycle instructions, while the data path was performing the first cycle, the microcode decoded four possible options for the second cycle. The decision as to which of these options would actually be used could be made near the end of the first cycle. This allowed for very fast operation while keeping the architecture generic.Stakem, Patrick H. The Hardware and Software Architecture of the Transputer, 2011, PRB Publishing, ASIN B004OYTS1K The clock speed of 20&nbsp;MHz was quite high for the era and the designers were very concerned about the practicalities of distributing a clock signal of this speed on a board. A lower external clock of 5&nbsp;MHz was used and this was multiplied up to the required internal frequency using a phase-locked loop (PLL). The internal clock actually had four non-overlapping phases and designers were free to use whichever combination of these they wanted so it could be argued that the transputer actually ran at 80&nbsp;MHz. Dynamic logic was used in many parts of the design to reduce area and increase speed. Unfortunately, these techniques are difficult to combine with automatic test pattern generation scan testing so they fell out of favour for later designs. Prentice-Hall published a bookhttp://dl.acm.org/citation.cfm?id=51254 on the general principles of the Transputer The basic design of the transputer included serial links that allowed it to communicate with up to four other transputers, each at 5, 10 or 20 Mbit/s &ndash; which was very fast for the 1980s. Any number of transputers could be connected together over links (which could run tens of metres) to form a single computing "farm". A hypothetical desktop machine might have two of the "low end" transputers handling I/O tasks on some of their serial lines (hooked up to appropriate hardware) while they talked to one of their larger cousins acting as a CPU on another. This serial link is called an os-link. Kazuto Tanaka; Satoshi Iwanami; Takeshi Yamakawa; Chikara Fukunaga; Kazuto Matsui; Takashi Yoshida. "The Design and Performance of SpaceWire Router-network using CSP". p. 2.  "High-Performance Computing and Networking: International Conference and Exhibition, Amsterdam, The Netherlands, April 21-23, 1998 Proceedings". B C O'Neill; G Coulson; K L Wong; R Hotchkiss; J H Ng; S Clark; and P D Thomas. "An Interface Device to Support a Distributed Parallel System for the StrongARM Microprocessor". p. 1031.  There were limits to the size of a system that could be built in this fashion. Since each transputer was linked to another in a fixed point-to-point layout, sending messages to a more distant transputer required the messages to be relayed by each chip on the line. This introduced a delay with every "hop" over a link, leading to long delays on large nets. To solve this problem Inmos also provided a zero-delay switch that connected up to 32 transputers (or switches) into even larger networks. Transputers could be booted over the network links (as opposed to the memory as in most machines) so a single transputer could start up the entire network. There was a pin called BootFromROM that when asserted caused the transputer to start two bytes from the top of memory (sufficient for up to a 256 byte backward jump, usually out of ROM). When this pin was not asserted, the first byte that arrived down any link was the length of a bootstrap to be downloaded, which was placed in low memory and run. The 'special' lengths of 0 and 1 were reserved for PEEK and POKE – allowing inspection and changing of RAM in an unbooted transputer. After a peek (which required an address) or a poke (which took a word address, and a word of data – 16 or 32 bit depending on the basic word width of the transputer variant) the transputer would return to waiting for a bootstrap. Supporting the links was additional circuitry that handled scheduling of the traffic over them. Processes waiting on communications would automatically pause while the networking circuitry finished its reads or writes. Other processes running on the transputer would then be given that processing time. It included two priority levels to improve real-time and multiprocessor operation. The same logical system was used to communicate between programs running on a single transputer, implemented as "virtual network links" in memory. So programs asking for any input or output automatically paused while the operation completed, a task that normally required the operating system to handle as the arbiter of hardware. Operating systems on the transputer did not have to handle scheduling: in fact, one could consider the chip itself to have an OS inside it. To include all this functionality on a single chip, the transputer's core logic was simpler than most CPUs.  While some have called it a RISC due to its rather sparse nature (and because that was a desirable marketing buzzword at the time), it was heavily microcoded, had a limited register set, and complex memory-to-memory instructions, all of which place it firmly in the CISC camp.  Unlike register-heavy load-store RISC CPUs, the transputer had only three data registers, which behaved as a stack.  In addition a Workspace Pointer pointed to a conventional memory stack, easily accessible via the Load Local and Store Local instructions.  This allowed for very fast context switching by simply changing the workspace pointer to the memory used by another process (a technique used in a number of contemporary designs, such as the TMS9900). The three register stack contents were not preserved past certain instructions, like Jump, when the transputer could do a context switch. The transputer instruction set comprised 8-bit instructions divided into opcode and operand nibbles. The "upper" nibble contained the 16 possible primary instruction codes, making it one of the very few commercialized minimal instruction set computers.  The "lower" nibble contained the single immediate constant operand, commonly used as an offset relative to the Workspace (memory stack) pointer.  Two prefix instructions allowed construction of larger constants by prepending their lower nibbles to the operands of following instructions. Additional instructions were supported via the Operate (Opr) instruction code, which decoded the constant operand as an extended zero-operand opcode, providing for almost endless and easy instruction set expansion as newer implementations of the transputer were introduced. The 16 'primary' one-operand instructions were: All these instructions take a constant, representing an offset or an arithmetic constant. If this constant was less than 16, all these instructions coded to a single byte. The first 16 'secondary' zero-operand instructions (using the OPR primary instruction) were:   To provide an easy means of prototyping, constructing and configuring multiple-transputer systems, Inmos introduced the TRAM (TRAnsputer Module) standard in 1987. A TRAM was essentially a building block daughterboard comprising a transputer and, optionally, external memory and/or peripheral devices, with simple standardised connectors providing power, transputer links, clock and system signals. Various sizes of TRAM were defined, from the basic Size 1 TRAM (3.66 in by 1.05 in) up to Size 8 (3.66 in by 8.75 in).  Inmos produced a range of TRAM motherboards for various host buses such as ISA, MicroChannel or VMEbus. TRAM links operate at 10&nbsp;Mbit/s or 20&nbsp;Mbit/s. Transputers were intended to be programmed using the occam programming language, based on the CSP process calculus. In fact it is fair to say that the transputer was built specifically to run occam, even more so than contemporary CISC designs were built to run languages like Pascal or C. Occam supported concurrency and channel-based inter-process or inter-processor communication as a fundamental part of the language. With the parallelism and communications built into the chip and the language interacting with it directly, writing code for things like device controllers became a triviality &ndash; even the most basic code could watch the serial ports for I/O, and would automatically sleep when there was no data. The initial occam development environment for the transputer was the Inmos  D700 Transputer Development System (TDS). This was an unorthodox integrated development environment incorporating an editor, compiler, linker and (post-mortem) debugger. The TDS was itself a transputer application written in occam. The TDS text editor was notable in that it was a folding editor, allowing blocks of code to be hidden and revealed, to make the structure of the code more apparent. Unfortunately, the combination of an unfamiliar programming language and equally unfamiliar development environment did nothing for the early popularity of the transputer. Later, Inmos would release more conventional occam cross-compilers, the occam 2 Toolsets. Implementations of more mainstream programming languages, such as C, FORTRAN, Ada and Pascal were also later released by both Inmos and third-party vendors. These usually included language extensions or libraries providing, in a less elegant way, occam-like concurrency and channel-based communication. The transputer's lack of support for virtual memory inhibited the porting of mainstream variants of the UNIX operating system, though ports of UNIX-like operating systems (such as Minix and Idris from Whitesmiths) were produced. An advanced UNIX-like distributed operating system, HeliOS, was also designed specifically for multi-transputer systems by Perihelion Software. The first transputers were announced in 1983 and released in 1984. In keeping with their role as microcontroller-like devices, they included on-board RAM and a built-in RAM controller which enabled more memory to be added without any additional hardware. Unlike other designs, transputers did not include I/O lines: these were to be added with hardware attached to the existing serial links. There was one 'Event' line, similar to a conventional processor's interrupt line. Treated as a channel, a program could 'input' from the event channel, and proceed only after the event line was asserted. All transputers ran from an external 5&nbsp;MHz clock input; this was multiplied to provide the processor clock. The transputer did not include an MMU or a virtual memory system. Transputer variants (excepting the cancelled T9000) can be categorised into three groups: the 16-bit T2 series, the 32-bit T4 series and the 32-bit T8 series with 64-bit IEEE 754 floating-point support. The prototype 16-bit transputer was the S43, which lacked the scheduler and DMA-controlled block transfer on the links. At launch, the T212 and M212 (the latter with an on-board disk controller) were the 16-bit offerings. The T212 was available in 17.5 and 20&nbsp;MHz processor clock speed ratings. The T212 was superseded by the T222, with on-chip RAM expanded from 2&nbsp;kB to 4&nbsp;kB, and, later, the T225. This added debugging breakpoint support (by extending the instruction J 0) plus some extra instructions from the T800 instruction set. Both the T222 and T225 ran at 20&nbsp;MHz. At launch, the T414 was the 32-bit offering. Originally, the first 32-bit variant was to be the T424, but fabrication difficulties meant that this was redesigned as the T414 with 2 kB on-board RAM instead of the intended 4 kB. The T414 was available in 15 and 20&nbsp;MHz varieties. The RAM was later reinstated to 4 kB on the T425 (in 20, 25 and 30&nbsp;MHz varieties), which also added the J 0 breakpoint support and extra T800 instructions. The T400, released in September 1989, was a  low-cost 20&nbsp;MHz T425 derivative with 2 kB and two instead of four links, intended for the embedded systems market. The second-generation T800 transputer, introduced in 1987, had an extended instruction set. The most important addition was  a 64-bit floating point unit and three additional registers for floating point, implementing the IEEE754-1985 floating point standard. It also had 4 kB of on-board RAM and was available in 20 or 25&nbsp;MHz versions. Breakpoint support was added in the later T801 and T805, the former featuring separate address and data buses to improve performance. The T805 was also later available as a 30&nbsp;MHz part. An enhanced T810 was planned, which would have had more RAM, more and faster links, extra instructions and improved microcode, but this was cancelled around 1990. Inmos also produced a variety of support chips for the transputer processors, such as the C004 32-way link switch and the C012 "link adapter" which allowed transputer links to be interfaced to an 8-bit data bus. Part of the original Inmos strategy was to make CPUs so small and cheap that they could be combined with other logic in a single device. Although SOCs as they are commonly known, are ubiquitous now, the concept was almost unheard of back in the early 1980s. Two projects were started in around 1983, the M212 and the 'TV-toy'. The M212 was based on a standard T212 core with the addition of a disk controller for the ST 506 and ST 412 Shugart standards. 'TV-toy' was to be the basis for a games console and was joint project between Inmos and Sinclair Research. The links in the T212 and T414/T424 transputers had hardware DMA engines so that transfers could happen in parallel with execution of other processes. A variant of the design, known as the T400, not to be confused with a later transputer of the same name, was designed where the CPU handled these transfers. This reduced the size of the device considerably since 4 link engines were approximately the same size as the whole CPU. The T400 was intended to be used as a core in what were then called 'SOS' ('systems on silicon') devices, now better known as SOCs. It was this design that was to form part of TV-toy. The project was canceled in 1985. Although the previous SOC projects had had only limited success (the M212 was in fact sold for a time), many designers still firmly believed in the concept and in 1987, a new project, the T100 was started which combined an 8-bit version of the transputer CPU with configurable logic based on state machines. The transputer instruction set is based on 8-bit instructions and can easily be used with any word size which is a multiple of 8 bits. The target market for the T100 was to be bus controllers such as Futurebus, as well as an upgrade for the standard link adapters (C011 etc.). The project was stopped when the T840 (later to become the basis of the T9000) was started. T2, T4 and T8-series transputers" perrow="6 Inmos T212, PREQUAL Inmos T222, PREQUAL STMicroelectronics IMST225 (Inmos T225). Inmos T400 Inmos T414 Inmos T425 Inmos T800, PREQUAL STMicroelectronics IMST805 (Inmos T805) TPCORE is an implementation of the transputer, including the os-links, that runs in a FPGA.  "Communicating Process Architectures 2004". p. 361. Makoto Tanaka; Naoya Fukuchi; Yutaka Ooki; and Chikara Fukunaga. "Design of a Transputer Core and its implementation in an FPGA". 2004.  Inmos improved on the performance of the T8 series transputers with the introduction of the T9000 (code-named H1 during development). The T9000 shared most features with the T800, but moved several pieces of the design into hardware and added several features for superscalar support. Unlike the earlier models, the T9000 had a true 16 kB high-speed cache (using random-replacement) instead of RAM, but also allowed it to be used as memory and included MMU-like functionality to handle all of this (known as the PMI). For additional speed the T9000 cached the top 32 locations of the stack, instead of three as in earlier versions. The T9000 used a five-stage pipeline for even more speed. An interesting addition was the grouperInmos T9000 CPU patent, "US patent 5742783", which would collect instructions out of the cache and group them into larger packages of 4 bytes to feed the pipeline faster. Groups then completed in a single cycle, as if they were single larger instructions working on a faster CPU. The link system was upgraded to a new 100&nbsp;MHz mode, but unlike the previous systems the links were no longer downwardly compatible. This new packet-based link protocol was called DS-Link,Inmos DS Link patent, "Communication Interface US patent 5341371" and later formed the basis of the IEEE 1355 serial interconnect standard. The T9000 also added link routing hardware called the VCP (Virtual Channel Processor) which changed the links from point-to-point to a true network,  allowing for the creation of any number of virtual channels on the links. This meant programs no longer had to be aware of the physical layout of the connections. A range of DS-Link support chips were also developed, including the C104 32-way crossbar switch, and the C101 link adapter. Long delays in the T9000's development meant that the faster load-store designs were already outperforming it by the time it was to be released. In fact it consistently failed to reach its own performance goal of beating by a factor of ten the T800: when the project was finally cancelled it was still achieving only about 36 MIPS at 50&nbsp;MHz.  The production delays gave rise to the quip that the best host architecture for a T9000 was an overhead projector. This was too much for Inmos, which did not have the funding needed to continue development. By this time, the company had been sold to SGS-Thomson (now STMicroelectronics), whose focus was the embedded systems market, and eventually the T9000 project was abandoned. However, a comprehensively redesigned 32-bit transputer intended for embedded applications, the ST20 series, was later produced, utilising some technology developed for the T9000. The ST20 core was incorporated into chipsets for set-top box and GPS applications. Although not strictly a transputer itself, the ST20 was heavily influenced by the T4 and T9 and did in fact form the basis of the T450 which was arguably the last of the transputers. The mission of the ST20 was to be a reusable core in the then emerging SOC market. In fact the original name of the ST20 was the RMC or Reusable Micro Core. The architecture was loosely based on the original T4 architecture with a microcode-controlled data path. It was however a complete redesign, using VHDL as the design language and with an optimized (and rewritten) microcode compiler. The project was conceived as early as 1990 when it was realized that the T9 would be too big for many applications. Actual design work started in mid-1992. Several trial designs were done, ranging from a very simple RISC-style CPU with complex instructions implemented in software via traps to a rather complex superscalar design similar in concept to the Tomasulo algorithm. The final design looked very similar to the original T4 core although some simple instruction grouping and a 'workspace cache' were added to help with performance. While the transputer was simple but powerful compared to many contemporary designs, it never came close to meeting its goal of being used universally in both CPU and microcontroller roles. In the microcontroller realm, the market was dominated by 8-bit machines where cost was the only serious consideration. Here, even the T2s were too powerful and expensive for most users. In the computer desktop/workstation world, the transputer was fairly fast (operating at about 10 MIPS at 20&nbsp;MHz). This was excellent performance for the early 1980s, but by the time the FPU-equipped T800 was shipping, other RISC designs had surpassed it. This could have been mitigated to a large extent if machines had used multiple transputers as planned, but T800s cost about $400 each when introduced, which meant a poor price/performance ratio. Few transputer-based workstation systems were designed; the most notable probably being the Atari Transputer Workstation. The transputer was more successful in the field of massively parallel computing, where several vendors produced transputer-based systems in the late 1980s. These included Meiko (founded by ex-Inmos employees), Floating Point Systems, Parsytechttp://www.parallab.uib.no/resources/history/113_1335.JPG and Parsys. Several British academic institutions founded research activities in the application of transputer-based parallel systems, including Bristol Polytechnic's Bristol Transputer Centre and the University of Edinburgh's Edinburgh Concurrent Supercomputer Project. In addition, the Data Acquisition and Second Level Trigger systems of the High Energy Physics ZEUS Experiment for the HERA collider at DESY was based on a network of over 300 synchronously clocked transputers divided into several subsystems. These controlled both the readout of the custom detector electronics and ran reconstruction algorithms for physics event selection. The parallel processing capabilities of the transputer were put to use commercially for image processing by the world's largest printing company, RR Donnelley & Sons, in the early 1990s. The ability to quickly transform digital images in preparation for print gave RR Donnelley a significant edge over their competitors. This development was led by Michael Bengtson in the RR Donnelley Technology Center. Within a few years, the processing capability of even desktop computers pushed aside the need for custom multi-processing systems for RR Donnelley. The German company Jäger Messtechnik used transputers for their early ADwin real-time data acquisition and control products.http://talontechsales.com/ADwinbrochure.pdf The transputer also appeared in products related to virtual reality such as the ProVision 100 system made by Division Limited of Bristol, featuring a combination of Intel i860, 486/33 and Toshiba HSP processors, together with T805 or T425 transputers, implementing a rendering engine that could then be accessed as a server by PC, Sun SPARCstation or VAX systems. Myriade, a European miniaturized satellite platform developed by Astrium Satellites and CNES, is based on the T805 and is scheduled to stay in production till about 2015. The asynchronous operation of the communications and the computational allowed the development of asynchronous algorithms, such as Bane's "Asychronous Polynomial Zero Finding" algorithm.T.L. Freeman and M.K. Bane, "Asynchronous Polynomial Zero-Finding Algorithms". Parallel Computing 17, pp. 673-681. (1991) The field of asynchronous algorithms, as well as the asynchronous implementation of current algorithms, is likely to play a key role in the move to Exascale computing. The HETE-2 spacecraft currently uses 4× T805 transputers and 8× DSP56001 yielding about 100 MIPS of performance. The Myriade platform, used for several micro-satellites including the Picard satellite, uses a T805 transputer yielding around 4 MIPS.   Ironically, additional internal parallelism has been the driving force behind improvements in conventional CPU designs. Instead of explicit thread-level parallelism (such as that found in the transputer), CPU designs exploited implicit parallelism at the instruction-level, inspecting code sequences for data dependencies and issuing multiple independent instructions to different execution units. This is known as superscalar processing. Superscalar processors are suited for optimising the execution of sequentially-constructed fragments of code. The combination of superscalar processing and speculative execution delivered a tangible performance increase on existing bodies of code – which were mostly written in Pascal, Fortran, C and C++. Given these substantial and regular performance improvements to existing code there was little incentive to rewrite software in languages or coding styles which expose more task-level parallelism. Nevertheless, the model of cooperating concurrent processors can still be found in cluster computing systems that dominate supercomputer design in the 21st century. Unlike the transputer architecture, the processing units in these systems typically utilize superscalar CPUs with access to substantial amounts of memory and disk storage, running conventional operating systems and network interfaces. Resulting from the more complex nodes, the software architecture used for coordinating the parallelism in such systems is typically far more heavyweight than in the transputer architecture. The fundamental transputer motivation remains, yet was masked for over 20 years by the repeated doubling of transistor counts. Inevitably, microprocessor designers finally ran out of uses for the additional physical resources – almost at the same time when technology scaling began to hit its limits. Power consumption and therefore heat dissipation requirements render further clock rate increases unfeasible. These factors led the industry towards solutions little different in essence from those proposed by Inmos. The most powerful supercomputers in the world, based on designs from Columbia University and built as IBM Blue Gene, are real-world incarnations of the transputer dream. They are vast assemblies of identical, relatively low-performance SoC chips. Recent trends have also tried to solve the transistor dilemma in ways that would have been too futuristic even for Inmos. On top of adding components to the CPU die and placing multiple dies in one system, modern processors increasingly place multiple cores in a single die. The transputer designers struggled to fit even one core into its transistor budget. Today designers, working with a 1000-fold increase in transistors, can now typically place many. One of the most recent commercial developments has emerged from XMOS, which has developed a family of embedded multi-core multi-threaded processors which resonate strongly with the transputer and Inmos. There is an emerging class of multicore/manycore processors taking the approach of a 'network on a chip' ,such as the CELL processor, adapteva epiphany architecture, Tilera,etc. The transputer and Inmos both not only left a legacy on the computing world but also established Bristol, UK as a hub for microelectronic design and innovation. Mnemonic Description J Jump — add immediate operand to instruction pointer. LDLP Load Local Pointer — load a Workspace-relative pointer onto the top of the register stack PFIX Prefix — general way to increase lower nibble of following primary instruction LDNL Load non-local — load a value offset from address at top of stack LDC Load constant — load constant operand onto the top of the register stack LDNLP Load Non-local pointer — Load address, offset from top of stack NFIX Negative prefix — general way to negate (and possibly increase) lower nibble LDL Load Local — load value offset from Workspace ADC Add Constant — add constant operand to top of register stack CALL Subroutine call — push instruction pointer and jump CJ Conditional jump — depending on value at top of register stack AJW Adjust workspace — add operand to workspace pointer EQC Equals constant — test if top of register stack equals constant operand STL Store local — store at constant offset from workspace STNL Store non-local — store at address offset from top of stack OPR Operate — general way to extend instruction set Mnemonic Description REV Reverse — swap two top items of register stack LB Load byte BSUB Byte subscript ENDP End process DIFF Difference ADD Add GCALL General Call — swap top of stack and instruction pointer IN Input — receive message PROD Product GT Greater Than — the only comparison instruction WSUB Word subscript OUT Output — send message SUB Subtract STARTP Start Process OUTBYTE Output Byte — send single-byte message OUTWORD Output word — send single-word message Ease programming language IEEE 1355 data interconnect standard derived from T9000 DS-links iWarp David May, transputer architect Meiko Computing Surface Adapteva ephiphany architecture a modern NoC many-core processor with 4 links per core/chip The Transputer FAQ Ram Meenakshisundaram's Transputer Home Page WoTUG A group applying the principles of transputers (e.g., CSP) in other environments. Transputer emulator – It emulates a single T414 transputer (i.e. no FPU, no blitting instructions) and supplies the file and terminal I/O services that were usually supplied by the host computer system. PC based Transputer emulator – This is a PC port of the original T414 transputer emulator (called jserver) written by Julian Highfield in the mid-late 90s. Transputers can be fun. The Transterpreter virtual machine. – A portable runtime for occam-pi and other languages based on the transputer bytecode. The Kent Retargettable occam compiler. – The occam-pi compiler. transputer.net. – Documents and more about transputer. Transtech Parallel Systems Ltd. – still supporting transputer based systems as of Q4 2009 (TRAMs with I/O like SCSI or with T225/T425/T805/ST20450 transputers); Maidenhead, UK Inmos alumni Directory of ex-Inmos employees, plus photos and general info. Maintained by Ken Heddings. Prince Philip Designers Prize Prince Philip Designers Prize winners from 1959–2009, Design Council website HETE-2 Spacecraft internal systems
